Require Import Coq.NArith.BinNat Coq.Reals.Reals HOLLight_Real_With_N.mappings HOLLight.mappings HOLLight_Logic1.mappings.
Definition _SEQPATTERN {A B : Type'} : (A -> B -> Prop) -> (A -> B -> Prop) -> A -> B -> Prop := fun r : A -> B -> Prop => fun s : A -> B -> Prop => fun x : A => @COND (B -> Prop) (exists y : B, r x y) (r x) (s x).
Lemma _SEQPATTERN_def {A B : Type'} : (@_SEQPATTERN A B) = (fun r : A -> B -> Prop => fun s : A -> B -> Prop => fun x : A => @COND (B -> Prop) (exists y : B, r x y) (r x) (s x)).
Proof. exact (eq_refl (@_SEQPATTERN A B)). Qed.
Definition _GUARDED_PATTERN : Prop -> Prop -> Prop -> Prop := fun p : Prop => fun g : Prop => fun r : Prop => p /\ (g /\ r).
Lemma _GUARDED_PATTERN_def : _GUARDED_PATTERN = (fun p : Prop => fun g : Prop => fun r : Prop => p /\ (g /\ r)).
Proof. exact (eq_refl _GUARDED_PATTERN). Qed.
Definition _MATCH {A B : Type'} : A -> (A -> B -> Prop) -> B := fun e : A => fun r : A -> B -> Prop => @COND B (@ex1 B (r e)) (@ε B (r e)) (@ε B (fun z : B => False)).
Lemma _MATCH_def {A B : Type'} : (@_MATCH A B) = (fun e : A => fun r : A -> B -> Prop => @COND B (@ex1 B (r e)) (@ε B (r e)) (@ε B (fun z : B => False))).
Proof. exact (eq_refl (@_MATCH A B)). Qed.
Definition _FUNCTION {A B : Type'} : (A -> B -> Prop) -> A -> B := fun r : A -> B -> Prop => fun x : A => @COND B (@ex1 B (r x)) (@ε B (r x)) (@ε B (fun z : B => False)).
Lemma _FUNCTION_def {A B : Type'} : (@_FUNCTION A B) = (fun r : A -> B -> Prop => fun x : A => @COND B (@ex1 B (r x)) (@ε B (r x)) (@ε B (fun z : B => False))).
Proof. exact (eq_refl (@_FUNCTION A B)). Qed.
Definition CURRY {A B C : Type'} : ((prod A B) -> C) -> A -> B -> C := fun _1283 : (prod A B) -> C => fun _1284 : A => fun _1285 : B => _1283 (@pair A B _1284 _1285).
Lemma CURRY_def {A B C : Type'} : (@CURRY A B C) = (fun _1283 : (prod A B) -> C => fun _1284 : A => fun _1285 : B => _1283 (@pair A B _1284 _1285)).
Proof. exact (eq_refl (@CURRY A B C)). Qed.
Definition UNCURRY {A B C : Type'} : (A -> B -> C) -> (prod A B) -> C := fun _1304 : A -> B -> C => fun _1305 : prod A B => _1304 (@fst A B _1305) (@snd A B _1305).
Lemma UNCURRY_def {A B C : Type'} : (@UNCURRY A B C) = (fun _1304 : A -> B -> C => fun _1305 : prod A B => _1304 (@fst A B _1305) (@snd A B _1305)).
Proof. exact (eq_refl (@UNCURRY A B C)). Qed.
Definition PASSOC {A B C D : Type'} : ((prod (prod A B) C) -> D) -> (prod A (prod B C)) -> D := fun _1321 : (prod (prod A B) C) -> D => fun _1322 : prod A (prod B C) => _1321 (@pair (prod A B) C (@pair A B (@fst A (prod B C) _1322) (@fst B C (@snd A (prod B C) _1322))) (@snd B C (@snd A (prod B C) _1322))).
Lemma PASSOC_def {A B C D : Type'} : (@PASSOC A B C D) = (fun _1321 : (prod (prod A B) C) -> D => fun _1322 : prod A (prod B C) => _1321 (@pair (prod A B) C (@pair A B (@fst A (prod B C) _1322) (@fst B C (@snd A (prod B C) _1322))) (@snd B C (@snd A (prod B C) _1322)))).
Proof. exact (eq_refl (@PASSOC A B C D)). Qed.
Definition minimal : (N -> Prop) -> N := fun _6536 : N -> Prop => @ε N (fun n : N => (_6536 n) /\ (forall m : N, (N.lt m n) -> ~ (_6536 m))).
Lemma minimal_def : minimal = (fun _6536 : N -> Prop => @ε N (fun n : N => (_6536 n) /\ (forall m : N, (N.lt m n) -> ~ (_6536 m)))).
Proof. exact (eq_refl minimal). Qed.
Definition FNIL {A : Type'} : N -> A := fun _17624 : N => @ε A (fun x : A => True).
Lemma FNIL_def {A : Type'} : (@FNIL A) = (fun _17624 : N => @ε A (fun x : A => True)).
Proof. exact (eq_refl (@FNIL A)). Qed.
Definition OUTL {A B : Type'} : (Datatypes.sum A B) -> A := @ε ((prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> A) (fun OUTL' : (prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> A => forall _17649 : prod N (prod N (prod N N)), forall x : A, (OUTL' _17649 (@inl A B x)) = x) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0))))))))))).
Lemma OUTL_def {A B : Type'} : (@OUTL A B) = (@ε ((prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> A) (fun OUTL' : (prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> A => forall _17649 : prod N (prod N (prod N N)), forall x : A, (OUTL' _17649 (@inl A B x)) = x) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))))))).
Proof. exact (eq_refl (@OUTL A B)). Qed.
Definition OUTR {A B : Type'} : (Datatypes.sum A B) -> B := @ε ((prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> B) (fun OUTR' : (prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> B => forall _17651 : prod N (prod N (prod N N)), forall y : B, (OUTR' _17651 (@inr A B y)) = y) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0))))))))))).
Lemma OUTR_def {A B : Type'} : (@OUTR A B) = (@ε ((prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> B) (fun OUTR' : (prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> B => forall _17651 : prod N (prod N (prod N N)), forall y : B, (OUTR' _17651 (@inr A B y)) = y) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))))))).
Proof. exact (eq_refl (@OUTR A B)). Qed.
Definition _22857 : Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Ascii.ascii := fun a0 : Prop => fun a1 : Prop => fun a2 : Prop => fun a3 : Prop => fun a4 : Prop => fun a5 : Prop => fun a6 : Prop => fun a7 : Prop => _mk_char ((fun a0' : Prop => fun a1' : Prop => fun a2' : Prop => fun a3' : Prop => fun a4' : Prop => fun a5' : Prop => fun a6' : Prop => fun a7' : Prop => @CONSTR (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))) (NUMERAL N0) (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))))) a0' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))) a1' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))) a2' (@pair Prop (prod Prop (prod Prop (prod Prop Prop))) a3' (@pair Prop (prod Prop (prod Prop Prop)) a4' (@pair Prop (prod Prop Prop) a5' (@pair Prop Prop a6' a7'))))))) (fun n : N => @BOTTOM (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))))) a0 a1 a2 a3 a4 a5 a6 a7).
Lemma _22857_def : _22857 = (fun a0 : Prop => fun a1 : Prop => fun a2 : Prop => fun a3 : Prop => fun a4 : Prop => fun a5 : Prop => fun a6 : Prop => fun a7 : Prop => _mk_char ((fun a0' : Prop => fun a1' : Prop => fun a2' : Prop => fun a3' : Prop => fun a4' : Prop => fun a5' : Prop => fun a6' : Prop => fun a7' : Prop => @CONSTR (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))) (NUMERAL N0) (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))))) a0' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))) a1' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))) a2' (@pair Prop (prod Prop (prod Prop (prod Prop Prop))) a3' (@pair Prop (prod Prop (prod Prop Prop)) a4' (@pair Prop (prod Prop Prop) a5' (@pair Prop Prop a6' a7'))))))) (fun n : N => @BOTTOM (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))))) a0 a1 a2 a3 a4 a5 a6 a7)).
Proof. exact (eq_refl _22857). Qed.
Definition ASCII : Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Ascii.ascii := _22857.
Lemma ASCII_def : ASCII = _22857.
Proof. exact (eq_refl ASCII). Qed.
Definition sqrt : R -> R := fun _27149 : R => @ε R (fun y : R => ((Rsgn y) = (Rsgn _27149)) /\ ((Rpow y (NUMERAL (BIT0 (BIT1 N0)))) = (Rabs _27149))).
Lemma sqrt_def : sqrt = (fun _27149 : R => @ε R (fun y : R => ((Rsgn y) = (Rsgn _27149)) /\ ((Rpow y (NUMERAL (BIT0 (BIT1 N0)))) = (Rabs _27149)))).
Proof. exact (eq_refl sqrt). Qed.
Definition DECIMAL : N -> N -> R := fun _27828 : N => fun _27829 : N => Rdiv (R_of_N _27828) (R_of_N _27829).
Lemma DECIMAL_def : DECIMAL = (fun _27828 : N => fun _27829 : N => Rdiv (R_of_N _27828) (R_of_N _27829)).
Proof. exact (eq_refl DECIMAL). Qed.
Definition eq2 {A : Type'} : A -> A -> (A -> A -> Prop) -> Prop := fun _29602 : A => fun _29603 : A => fun _29604 : A -> A -> Prop => _29604 _29602 _29603.
Lemma eq2_def {A : Type'} : (@eq2 A) = (fun _29602 : A => fun _29603 : A => fun _29604 : A -> A -> Prop => _29604 _29602 _29603).
Proof. exact (eq_refl (@eq2 A)). Qed.
Definition int_mod : Z -> Z -> Z -> Prop := fun _29664 : Z => fun _29665 : Z => fun _29666 : Z => Z.divide _29664 (Z.sub _29665 _29666).
Lemma int_mod_def : int_mod = (fun _29664 : Z => fun _29665 : Z => fun _29666 : Z => Z.divide _29664 (Z.sub _29665 _29666)).
Proof. exact (eq_refl int_mod). Qed.
Definition num_of_int : Z -> N := fun _31234 : Z => @ε N (fun n : N => (Z_of_N n) = _31234).
Lemma num_of_int_def : num_of_int = (fun _31234 : Z => @ε N (fun n : N => (Z_of_N n) = _31234)).
Proof. exact (eq_refl num_of_int). Qed.
Definition num_divides : N -> N -> Prop := fun _31266 : N => fun _31267 : N => Z.divide (Z_of_N _31266) (Z_of_N _31267).
Lemma num_divides_def : num_divides = (fun _31266 : N => fun _31267 : N => Z.divide (Z_of_N _31266) (Z_of_N _31267)).
Proof. exact (eq_refl num_divides). Qed.
Definition num_mod : N -> N -> N -> Prop := fun _31278 : N => fun _31279 : N => fun _31280 : N => int_mod (Z_of_N _31278) (Z_of_N _31279) (Z_of_N _31280).
Lemma num_mod_def : num_mod = (fun _31278 : N => fun _31279 : N => fun _31280 : N => int_mod (Z_of_N _31278) (Z_of_N _31279) (Z_of_N _31280)).
Proof. exact (eq_refl num_mod). Qed.
Definition num_coprime : (prod N N) -> Prop := fun _31299 : prod N N => int_coprime (@pair Z Z (Z_of_N (@fst N N _31299)) (Z_of_N (@snd N N _31299))).
Lemma num_coprime_def : num_coprime = (fun _31299 : prod N N => int_coprime (@pair Z Z (Z_of_N (@fst N N _31299)) (Z_of_N (@snd N N _31299)))).
Proof. exact (eq_refl num_coprime). Qed.
Definition num_gcd : (prod N N) -> N := fun _31308 : prod N N => num_of_int (int_gcd (@pair Z Z (Z_of_N (@fst N N _31308)) (Z_of_N (@snd N N _31308)))).
Lemma num_gcd_def : num_gcd = (fun _31308 : prod N N => num_of_int (int_gcd (@pair Z Z (Z_of_N (@fst N N _31308)) (Z_of_N (@snd N N _31308))))).
Proof. exact (eq_refl num_gcd). Qed.
Definition num_lcm : (prod N N) -> N := fun _31317 : prod N N => num_of_int (int_lcm (@pair Z Z (Z_of_N (@fst N N _31317)) (Z_of_N (@snd N N _31317)))).
Lemma num_lcm_def : num_lcm = (fun _31317 : prod N N => num_of_int (int_lcm (@pair Z Z (Z_of_N (@fst N N _31317)) (Z_of_N (@snd N N _31317))))).
Proof. exact (eq_refl num_lcm). Qed.
Definition prime : N -> Prop := fun _32102 : N => (~ (_32102 = (NUMERAL (BIT1 N0)))) /\ (forall x : N, (num_divides x _32102) -> (x = (NUMERAL (BIT1 N0))) \/ (x = _32102)).
Lemma prime_def : prime = (fun _32102 : N => (~ (_32102 = (NUMERAL (BIT1 N0)))) /\ (forall x : N, (num_divides x _32102) -> (x = (NUMERAL (BIT1 N0))) \/ (x = _32102))).
Proof. exact (eq_refl prime). Qed.
Definition real_zpow : R -> Z -> R := fun _32260 : R => fun _32261 : Z => @COND R (Z.le (Z_of_N (NUMERAL N0)) _32261) (Rpow _32260 (num_of_int _32261)) (Rinv (Rpow _32260 (num_of_int (Z.opp _32261)))).
Lemma real_zpow_def : real_zpow = (fun _32260 : R => fun _32261 : Z => @COND R (Z.le (Z_of_N (NUMERAL N0)) _32261) (Rpow _32260 (num_of_int _32261)) (Rinv (Rpow _32260 (num_of_int (Z.opp _32261))))).
Proof. exact (eq_refl real_zpow). Qed.
Definition INFINITE {A : Type'} : (A -> Prop) -> Prop := fun _32488 : A -> Prop => ~ (@FINITE A _32488).
Lemma INFINITE_def {A : Type'} : (@INFINITE A) = (fun _32488 : A -> Prop => ~ (@FINITE A _32488)).
Proof. exact (eq_refl (@INFINITE A)). Qed.
Definition INJ {A B : Type'} : (A -> B) -> (A -> Prop) -> (B -> Prop) -> Prop := fun _32505 : A -> B => fun _32506 : A -> Prop => fun _32507 : B -> Prop => (forall x : A, (@IN A x _32506) -> @IN B (_32505 x) _32507) /\ (forall x : A, forall y : A, ((@IN A x _32506) /\ ((@IN A y _32506) /\ ((_32505 x) = (_32505 y)))) -> x = y).
Lemma INJ_def {A B : Type'} : (@INJ A B) = (fun _32505 : A -> B => fun _32506 : A -> Prop => fun _32507 : B -> Prop => (forall x : A, (@IN A x _32506) -> @IN B (_32505 x) _32507) /\ (forall x : A, forall y : A, ((@IN A x _32506) /\ ((@IN A y _32506) /\ ((_32505 x) = (_32505 y)))) -> x = y)).
Proof. exact (eq_refl (@INJ A B)). Qed.
Definition SURJ {A B : Type'} : (A -> B) -> (A -> Prop) -> (B -> Prop) -> Prop := fun _32526 : A -> B => fun _32527 : A -> Prop => fun _32528 : B -> Prop => (forall x : A, (@IN A x _32527) -> @IN B (_32526 x) _32528) /\ (forall x : B, (@IN B x _32528) -> exists y : A, (@IN A y _32527) /\ ((_32526 y) = x)).
Lemma SURJ_def {A B : Type'} : (@SURJ A B) = (fun _32526 : A -> B => fun _32527 : A -> Prop => fun _32528 : B -> Prop => (forall x : A, (@IN A x _32527) -> @IN B (_32526 x) _32528) /\ (forall x : B, (@IN B x _32528) -> exists y : A, (@IN A y _32527) /\ ((_32526 y) = x))).
Proof. exact (eq_refl (@SURJ A B)). Qed.
Definition BIJ {A B : Type'} : (A -> B) -> (A -> Prop) -> (B -> Prop) -> Prop := fun _32547 : A -> B => fun _32548 : A -> Prop => fun _32549 : B -> Prop => (@INJ A B _32547 _32548 _32549) /\ (@SURJ A B _32547 _32548 _32549).
Lemma BIJ_def {A B : Type'} : (@BIJ A B) = (fun _32547 : A -> B => fun _32548 : A -> Prop => fun _32549 : B -> Prop => (@INJ A B _32547 _32548 _32549) /\ (@SURJ A B _32547 _32548 _32549)).
Proof. exact (eq_refl (@BIJ A B)). Qed.
Definition CHOICE {A : Type'} : (A -> Prop) -> A := fun _32568 : A -> Prop => @ε A (fun x : A => @IN A x _32568).
Lemma CHOICE_def {A : Type'} : (@CHOICE A) = (fun _32568 : A -> Prop => @ε A (fun x : A => @IN A x _32568)).
Proof. exact (eq_refl (@CHOICE A)). Qed.
Definition REST {A : Type'} : (A -> Prop) -> A -> Prop := fun _32573 : A -> Prop => @Ensembles.Subtract A _32573 (@CHOICE A _32573).
Lemma REST_def {A : Type'} : (@REST A) = (fun _32573 : A -> Prop => @Ensembles.Subtract A _32573 (@CHOICE A _32573)).
Proof. exact (eq_refl (@REST A)). Qed.
Definition FINREC {A B : Type'} : (A -> B -> B) -> B -> (A -> Prop) -> B -> N -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> N -> Prop) (fun FINREC' : (prod N (prod N (prod N (prod N (prod N N))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> N -> Prop => forall _42175 : prod N (prod N (prod N (prod N (prod N N)))), (forall f : A -> B -> B, forall s : A -> Prop, forall a : B, forall b : B, (FINREC' _42175 f b s a (NUMERAL N0)) = ((s = (@Ensembles.Empty_set A)) /\ (a = b))) /\ (forall b : B, forall s : A -> Prop, forall n : N, forall a : B, forall f : A -> B -> B, (FINREC' _42175 f b s a (N.succ n)) = (exists x : A, exists c : B, (@IN A x s) /\ ((FINREC' _42175 f b (@Ensembles.Subtract A s x) c n) /\ (a = (f x c)))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 N0))))))))))))).
Lemma FINREC_def {A B : Type'} : (@FINREC A B) = (@ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> N -> Prop) (fun FINREC' : (prod N (prod N (prod N (prod N (prod N N))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> N -> Prop => forall _42175 : prod N (prod N (prod N (prod N (prod N N)))), (forall f : A -> B -> B, forall s : A -> Prop, forall a : B, forall b : B, (FINREC' _42175 f b s a (NUMERAL N0)) = ((s = (@Ensembles.Empty_set A)) /\ (a = b))) /\ (forall b : B, forall s : A -> Prop, forall n : N, forall a : B, forall f : A -> B -> B, (FINREC' _42175 f b s a (N.succ n)) = (exists x : A, exists c : B, (@IN A x s) /\ ((FINREC' _42175 f b (@Ensembles.Subtract A s x) c n) /\ (a = (f x c)))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))))))))).
Proof. exact (eq_refl (@FINREC A B)). Qed.
Definition HAS_SIZE {A : Type'} : (A -> Prop) -> N -> Prop := fun _43403 : A -> Prop => fun _43404 : N => (@FINITE A _43403) /\ ((@CARD A _43403) = _43404).
Lemma HAS_SIZE_def {A : Type'} : (@HAS_SIZE A) = (fun _43403 : A -> Prop => fun _43404 : N => (@FINITE A _43403) /\ ((@CARD A _43403) = _43404)).
Proof. exact (eq_refl (@HAS_SIZE A)). Qed.
Definition CROSS {A B : Type'} : (A -> Prop) -> (B -> Prop) -> (prod A B) -> Prop := fun _47322 : A -> Prop => fun _47323 : B -> Prop => @GSPEC (prod A B) (fun GEN_PVAR_132 : prod A B => exists x : A, exists y : B, @SETSPEC (prod A B) GEN_PVAR_132 ((@IN A x _47322) /\ (@IN B y _47323)) (@pair A B x y)).
Lemma CROSS_def {A B : Type'} : (@CROSS A B) = (fun _47322 : A -> Prop => fun _47323 : B -> Prop => @GSPEC (prod A B) (fun GEN_PVAR_132 : prod A B => exists x : A, exists y : B, @SETSPEC (prod A B) GEN_PVAR_132 ((@IN A x _47322) /\ (@IN B y _47323)) (@pair A B x y))).
Proof. exact (eq_refl (@CROSS A B)). Qed.
Definition ARB {A : Type'} : A := @ε A (fun x : A => False).
Lemma ARB_def {A : Type'} : (@ARB A) = (@ε A (fun x : A => False)).
Proof. exact (eq_refl (@ARB A)). Qed.
Definition EXTENSIONAL {A B : Type'} : (A -> Prop) -> (A -> B) -> Prop := fun _48096 : A -> Prop => @GSPEC (A -> B) (fun GEN_PVAR_141 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_141 (forall x : A, (~ (@IN A x _48096)) -> (f x) = (@ARB B)) f).
Lemma EXTENSIONAL_def {A B : Type'} : (@EXTENSIONAL A B) = (fun _48096 : A -> Prop => @GSPEC (A -> B) (fun GEN_PVAR_141 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_141 (forall x : A, (~ (@IN A x _48096)) -> (f x) = (@ARB B)) f)).
Proof. exact (eq_refl (@EXTENSIONAL A B)). Qed.
Definition RESTRICTION {A B : Type'} : (A -> Prop) -> (A -> B) -> A -> B := fun _48148 : A -> Prop => fun _48149 : A -> B => fun _48150 : A => @COND B (@IN A _48150 _48148) (_48149 _48150) (@ARB B).
Lemma RESTRICTION_def {A B : Type'} : (@RESTRICTION A B) = (fun _48148 : A -> Prop => fun _48149 : A -> B => fun _48150 : A => @COND B (@IN A _48150 _48148) (_48149 _48150) (@ARB B)).
Proof. exact (eq_refl (@RESTRICTION A B)). Qed.
Definition cartesian_product {A K : Type'} : (K -> Prop) -> (K -> A -> Prop) -> (K -> A) -> Prop := fun _48343 : K -> Prop => fun _48344 : K -> A -> Prop => @GSPEC (K -> A) (fun GEN_PVAR_142 : K -> A => exists f : K -> A, @SETSPEC (K -> A) GEN_PVAR_142 ((@EXTENSIONAL K A _48343 f) /\ (forall i : K, (@IN K i _48343) -> @IN A (f i) (_48344 i))) f).
Lemma cartesian_product_def {A K : Type'} : (@cartesian_product A K) = (fun _48343 : K -> Prop => fun _48344 : K -> A -> Prop => @GSPEC (K -> A) (fun GEN_PVAR_142 : K -> A => exists f : K -> A, @SETSPEC (K -> A) GEN_PVAR_142 ((@EXTENSIONAL K A _48343 f) /\ (forall i : K, (@IN K i _48343) -> @IN A (f i) (_48344 i))) f)).
Proof. exact (eq_refl (@cartesian_product A K)). Qed.
Definition product_map {A B K : Type'} : (K -> Prop) -> (K -> A -> B) -> (K -> A) -> K -> B := fun _49392 : K -> Prop => fun _49393 : K -> A -> B => fun x : K -> A => @RESTRICTION K B _49392 (fun i : K => _49393 i (x i)).
Lemma product_map_def {A B K : Type'} : (@product_map A B K) = (fun _49392 : K -> Prop => fun _49393 : K -> A -> B => fun x : K -> A => @RESTRICTION K B _49392 (fun i : K => _49393 i (x i))).
Proof. exact (eq_refl (@product_map A B K)). Qed.
Definition disjoint_union {A K : Type'} : (K -> Prop) -> (K -> A -> Prop) -> (prod K A) -> Prop := fun _49528 : K -> Prop => fun _49529 : K -> A -> Prop => @GSPEC (prod K A) (fun GEN_PVAR_145 : prod K A => exists i : K, exists x : A, @SETSPEC (prod K A) GEN_PVAR_145 ((@IN K i _49528) /\ (@IN A x (_49529 i))) (@pair K A i x)).
Lemma disjoint_union_def {A K : Type'} : (@disjoint_union A K) = (fun _49528 : K -> Prop => fun _49529 : K -> A -> Prop => @GSPEC (prod K A) (fun GEN_PVAR_145 : prod K A => exists i : K, exists x : A, @SETSPEC (prod K A) GEN_PVAR_145 ((@IN K i _49528) /\ (@IN A x (_49529 i))) (@pair K A i x))).
Proof. exact (eq_refl (@disjoint_union A K)). Qed.
Definition pairwise {A : Type'} : (A -> A -> Prop) -> (A -> Prop) -> Prop := fun _56616 : A -> A -> Prop => fun _56617 : A -> Prop => forall x : A, forall y : A, ((@IN A x _56617) /\ ((@IN A y _56617) /\ (~ (x = y)))) -> _56616 x y.
Lemma pairwise_def {A : Type'} : (@pairwise A) = (fun _56616 : A -> A -> Prop => fun _56617 : A -> Prop => forall x : A, forall y : A, ((@IN A x _56617) /\ ((@IN A y _56617) /\ (~ (x = y)))) -> _56616 x y).
Proof. exact (eq_refl (@pairwise A)). Qed.
Definition UNION_OF {A : Type'} : (((A -> Prop) -> Prop) -> Prop) -> ((A -> Prop) -> Prop) -> (A -> Prop) -> Prop := fun _57329 : ((A -> Prop) -> Prop) -> Prop => fun _57330 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57329 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57330 c) /\ ((@UNIONS A u) = s)).
Lemma UNION_OF_def {A : Type'} : (@UNION_OF A) = (fun _57329 : ((A -> Prop) -> Prop) -> Prop => fun _57330 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57329 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57330 c) /\ ((@UNIONS A u) = s))).
Proof. exact (eq_refl (@UNION_OF A)). Qed.
Definition INTERSECTION_OF {A : Type'} : (((A -> Prop) -> Prop) -> Prop) -> ((A -> Prop) -> Prop) -> (A -> Prop) -> Prop := fun _57341 : ((A -> Prop) -> Prop) -> Prop => fun _57342 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57341 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57342 c) /\ ((@INTERS A u) = s)).
Lemma INTERSECTION_OF_def {A : Type'} : (@INTERSECTION_OF A) = (fun _57341 : ((A -> Prop) -> Prop) -> Prop => fun _57342 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57341 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57342 c) /\ ((@INTERS A u) = s))).
Proof. exact (eq_refl (@INTERSECTION_OF A)). Qed.
Definition ARBITRARY {A : Type'} : ((A -> Prop) -> Prop) -> Prop := fun _57477 : (A -> Prop) -> Prop => True.
Lemma ARBITRARY_def {A : Type'} : (@ARBITRARY A) = (fun _57477 : (A -> Prop) -> Prop => True).
Proof. exact (eq_refl (@ARBITRARY A)). Qed.
Definition le_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64071 : A -> Prop => fun _64072 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64071) -> @IN B (f x) _64072) /\ (forall x : A, forall y : A, ((@IN A x _64071) /\ ((@IN A y _64071) /\ ((f x) = (f y)))) -> x = y).
Lemma le_c_def {A B : Type'} : (@le_c A B) = (fun _64071 : A -> Prop => fun _64072 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64071) -> @IN B (f x) _64072) /\ (forall x : A, forall y : A, ((@IN A x _64071) /\ ((@IN A y _64071) /\ ((f x) = (f y)))) -> x = y)).
Proof. exact (eq_refl (@le_c A B)). Qed.
Definition lt_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64083 : A -> Prop => fun _64084 : B -> Prop => (@le_c A B _64083 _64084) /\ (~ (@le_c B A _64084 _64083)).
Lemma lt_c_def {A B : Type'} : (@lt_c A B) = (fun _64083 : A -> Prop => fun _64084 : B -> Prop => (@le_c A B _64083 _64084) /\ (~ (@le_c B A _64084 _64083))).
Proof. exact (eq_refl (@lt_c A B)). Qed.
Definition eq_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64095 : A -> Prop => fun _64096 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64095) -> @IN B (f x) _64096) /\ (forall y : B, (@IN B y _64096) -> @ex1 A (fun x : A => (@IN A x _64095) /\ ((f x) = y))).
Lemma eq_c_def {A B : Type'} : (@eq_c A B) = (fun _64095 : A -> Prop => fun _64096 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64095) -> @IN B (f x) _64096) /\ (forall y : B, (@IN B y _64096) -> @ex1 A (fun x : A => (@IN A x _64095) /\ ((f x) = y)))).
Proof. exact (eq_refl (@eq_c A B)). Qed.
Definition ge_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64107 : A -> Prop => fun _64108 : B -> Prop => @le_c B A _64108 _64107.
Lemma ge_c_def {A B : Type'} : (@ge_c A B) = (fun _64107 : A -> Prop => fun _64108 : B -> Prop => @le_c B A _64108 _64107).
Proof. exact (eq_refl (@ge_c A B)). Qed.
Definition gt_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64119 : A -> Prop => fun _64120 : B -> Prop => @lt_c B A _64120 _64119.
Lemma gt_c_def {A B : Type'} : (@gt_c A B) = (fun _64119 : A -> Prop => fun _64120 : B -> Prop => @lt_c B A _64120 _64119).
Proof. exact (eq_refl (@gt_c A B)). Qed.
Definition COUNTABLE {A : Type'} : (A -> Prop) -> Prop := fun _64270 : A -> Prop => @ge_c N A (@Ensembles.Full_set N) _64270.
Lemma COUNTABLE_def {A : Type'} : (@COUNTABLE A) = (fun _64270 : A -> Prop => @ge_c N A (@Ensembles.Full_set N) _64270).
Proof. exact (eq_refl (@COUNTABLE A)). Qed.
Definition sup : (R -> Prop) -> R := fun _64275 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _64275) -> Rle x a) /\ (forall b : R, (forall x : R, (@IN R x _64275) -> Rle x b) -> Rle a b)).
Lemma sup_def : sup = (fun _64275 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _64275) -> Rle x a) /\ (forall b : R, (forall x : R, (@IN R x _64275) -> Rle x b) -> Rle a b))).
Proof. exact (eq_refl sup). Qed.
Definition inf : (R -> Prop) -> R := fun _65134 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _65134) -> Rle a x) /\ (forall b : R, (forall x : R, (@IN R x _65134) -> Rle b x) -> Rle b a)).
Lemma inf_def : inf = (fun _65134 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _65134) -> Rle a x) /\ (forall b : R, (forall x : R, (@IN R x _65134) -> Rle b x) -> Rle b a))).
Proof. exact (eq_refl inf). Qed.
Definition has_inf : (R -> Prop) -> R -> Prop := fun _66484 : R -> Prop => fun _66485 : R => forall c : R, (forall x : R, (@IN R x _66484) -> Rle c x) = (Rle c _66485).
Lemma has_inf_def : has_inf = (fun _66484 : R -> Prop => fun _66485 : R => forall c : R, (forall x : R, (@IN R x _66484) -> Rle c x) = (Rle c _66485)).
Proof. exact (eq_refl has_inf). Qed.
Definition has_sup : (R -> Prop) -> R -> Prop := fun _66496 : R -> Prop => fun _66497 : R => forall c : R, (forall x : R, (@IN R x _66496) -> Rle x c) = (Rle _66497 c).
Lemma has_sup_def : has_sup = (fun _66496 : R -> Prop => fun _66497 : R => forall c : R, (forall x : R, (@IN R x _66496) -> Rle x c) = (Rle _66497 c)).
Proof. exact (eq_refl has_sup). Qed.
Definition neutral {A : Type'} : (A -> A -> A) -> A := fun _68834 : A -> A -> A => @ε A (fun x : A => forall y : A, ((_68834 x y) = y) /\ ((_68834 y x) = y)).
Lemma neutral_def {A : Type'} : (@neutral A) = (fun _68834 : A -> A -> A => @ε A (fun x : A => forall y : A, ((_68834 x y) = y) /\ ((_68834 y x) = y))).
Proof. exact (eq_refl (@neutral A)). Qed.
Definition monoidal {A : Type'} : (A -> A -> A) -> Prop := fun _68839 : A -> A -> A => (forall x : A, forall y : A, (_68839 x y) = (_68839 y x)) /\ ((forall x : A, forall y : A, forall z : A, (_68839 x (_68839 y z)) = (_68839 (_68839 x y) z)) /\ (forall x : A, (_68839 (@neutral A _68839) x) = x)).
Lemma monoidal_def {A : Type'} : (@monoidal A) = (fun _68839 : A -> A -> A => (forall x : A, forall y : A, (_68839 x y) = (_68839 y x)) /\ ((forall x : A, forall y : A, forall z : A, (_68839 x (_68839 y z)) = (_68839 (_68839 x y) z)) /\ (forall x : A, (_68839 (@neutral A _68839) x) = x))).
Proof. exact (eq_refl (@monoidal A)). Qed.
Definition support {A B : Type'} : (B -> B -> B) -> (A -> B) -> (A -> Prop) -> A -> Prop := fun _68924 : B -> B -> B => fun _68925 : A -> B => fun _68926 : A -> Prop => @GSPEC A (fun GEN_PVAR_239 : A => exists x : A, @SETSPEC A GEN_PVAR_239 ((@IN A x _68926) /\ (~ ((_68925 x) = (@neutral B _68924)))) x).
Lemma support_def {A B : Type'} : (@support A B) = (fun _68924 : B -> B -> B => fun _68925 : A -> B => fun _68926 : A -> Prop => @GSPEC A (fun GEN_PVAR_239 : A => exists x : A, @SETSPEC A GEN_PVAR_239 ((@IN A x _68926) /\ (~ ((_68925 x) = (@neutral B _68924)))) x)).
Proof. exact (eq_refl (@support A B)). Qed.
Definition iterate {A B : Type'} : (B -> B -> B) -> (A -> Prop) -> (A -> B) -> B := fun _68945 : B -> B -> B => fun _68946 : A -> Prop => fun _68947 : A -> B => @COND B (@FINITE A (@support A B _68945 _68947 _68946)) (@ITSET A B (fun x : A => fun a : B => _68945 (_68947 x) a) (@support A B _68945 _68947 _68946) (@neutral B _68945)) (@neutral B _68945).
Lemma iterate_def {A B : Type'} : (@iterate A B) = (fun _68945 : B -> B -> B => fun _68946 : A -> Prop => fun _68947 : A -> B => @COND B (@FINITE A (@support A B _68945 _68947 _68946)) (@ITSET A B (fun x : A => fun a : B => _68945 (_68947 x) a) (@support A B _68945 _68947 _68946) (@neutral B _68945)) (@neutral B _68945)).
Proof. exact (eq_refl (@iterate A B)). Qed.
Definition iterato {A K : Type'} : (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A := @ε ((prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A) (fun itty : (prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A => forall _76701 : prod N (prod N (prod N (prod N (prod N (prod N N))))), forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall k : K -> Prop, forall f : K -> A, (itty _76701 dom neut op ltle k f) = (@COND A ((@FINITE K (@GSPEC K (fun GEN_PVAR_265 : K => exists i : K, @SETSPEC K GEN_PVAR_265 ((@IN K i k) /\ (@IN A (f i) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A))))) i))) /\ (~ ((@GSPEC K (fun GEN_PVAR_266 : K => exists i : K, @SETSPEC K GEN_PVAR_266 ((@IN K i k) /\ (@IN A (f i) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A))))) i)) = (@Ensembles.Empty_set K)))) (@Basics.apply K A (fun i : K => @Datatypes.id A (op (f i) (itty _76701 dom neut op ltle (@GSPEC K (fun GEN_PVAR_267 : K => exists j : K, @SETSPEC K GEN_PVAR_267 ((@IN K j (@Ensembles.Subtract K k i)) /\ (@IN A (f j) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A))))) j)) f))) (@COND K (exists i : K, (@IN K i k) /\ ((@IN A (f i) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A)))))) -> j = i))) (@ε K (fun i : K => (@IN K i k) /\ ((@IN A (f i) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A)))))) -> j = i)))) (@ε K (fun i : K => (@IN K i k) /\ (@IN A (f i) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A)))))))) neut)) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))))))))).
Lemma iterato_def {A K : Type'} : (@iterato A K) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A) (fun itty : (prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A => forall _76701 : prod N (prod N (prod N (prod N (prod N (prod N N))))), forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall k : K -> Prop, forall f : K -> A, (itty _76701 dom neut op ltle k f) = (@COND A ((@FINITE K (@GSPEC K (fun GEN_PVAR_265 : K => exists i : K, @SETSPEC K GEN_PVAR_265 ((@IN K i k) /\ (@IN A (f i) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A))))) i))) /\ (~ ((@GSPEC K (fun GEN_PVAR_266 : K => exists i : K, @SETSPEC K GEN_PVAR_266 ((@IN K i k) /\ (@IN A (f i) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A))))) i)) = (@Ensembles.Empty_set K)))) (@Basics.apply K A (fun i : K => @Datatypes.id A (op (f i) (itty _76701 dom neut op ltle (@GSPEC K (fun GEN_PVAR_267 : K => exists j : K, @SETSPEC K GEN_PVAR_267 ((@IN K j (@Ensembles.Subtract K k i)) /\ (@IN A (f j) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A))))) j)) f))) (@COND K (exists i : K, (@IN K i k) /\ ((@IN A (f i) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A)))))) -> j = i))) (@ε K (fun i : K => (@IN K i k) /\ ((@IN A (f i) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A)))))) -> j = i)))) (@ε K (fun i : K => (@IN K i k) /\ (@IN A (f i) (@Ensembles.Setminus A dom (@INSERT A neut (@Ensembles.Empty_set A)))))))) neut)) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0))))))))))))))).
Proof. exact (eq_refl (@iterato A K)). Qed.
Definition nproduct {A : Type'} : (A -> Prop) -> (A -> N) -> N := @iterate A N N.mul.
Lemma nproduct_def {A : Type'} : (@nproduct A) = (@iterate A N N.mul).
Proof. exact (eq_refl (@nproduct A)). Qed.
Definition iproduct {A : Type'} : (A -> Prop) -> (A -> Z) -> Z := @iterate A Z Z.mul.
Lemma iproduct_def {A : Type'} : (@iproduct A) = (@iterate A Z Z.mul).
Proof. exact (eq_refl (@iproduct A)). Qed.
Definition product {A : Type'} : (A -> Prop) -> (A -> R) -> R := @iterate A R Rmult.
Lemma product_def {A : Type'} : (@product A) = (@iterate A R Rmult).
Proof. exact (eq_refl (@product A)). Qed.
Definition isum {A : Type'} : (A -> Prop) -> (A -> Z) -> Z := @iterate A Z Z.add.
Lemma isum_def {A : Type'} : (@isum A) = (@iterate A Z Z.add).
Proof. exact (eq_refl (@isum A)). Qed.
Definition nsum {A : Type'} : (A -> Prop) -> (A -> N) -> N := @iterate A N N.add.
Lemma nsum_def {A : Type'} : (@nsum A) = (@iterate A N N.add).
Proof. exact (eq_refl (@nsum A)). Qed.
Definition sum {A : Type'} : (A -> Prop) -> (A -> R) -> R := @iterate A R Rplus.
Lemma sum_def {A : Type'} : (@sum A) = (@iterate A R Rplus).
Proof. exact (eq_refl (@sum A)). Qed.
Definition polynomial_function : (R -> R) -> Prop := fun _94114 : R -> R => exists m : N, exists c : N -> R, forall x : R, (_94114 x) = (@sum N (dotdot (NUMERAL N0) m) (fun i : N => Rmult (c i) (Rpow x i))).
Lemma polynomial_function_def : polynomial_function = (fun _94114 : R -> R => exists m : N, exists c : N -> R, forall x : R, (_94114 x) = (@sum N (dotdot (NUMERAL N0) m) (fun i : N => Rmult (c i) (Rpow x i)))).
Proof. exact (eq_refl polynomial_function). Qed.
Definition dollar {A N' : Type'} : (cart A N') -> N -> A := fun _94566 : cart A N' => fun _94567 : N => @dest_cart A N' _94566 (@finite_index N' _94567).
Lemma dollar_def {A N' : Type'} : (@dollar A N') = (fun _94566 : cart A N' => fun _94567 : N => @dest_cart A N' _94566 (@finite_index N' _94567)).
Proof. exact (eq_refl (@dollar A N')). Qed.
Definition lambda {A B : Type'} : (N -> A) -> cart A B := fun _94602 : N -> A => @ε (cart A B) (fun f : cart A B => forall i : N, ((N.le (NUMERAL (BIT1 N0)) i) /\ (N.le i (@dimindex B (@Ensembles.Full_set B)))) -> (@dollar A B f i) = (_94602 i)).
Lemma lambda_def {A B : Type'} : (@lambda A B) = (fun _94602 : N -> A => @ε (cart A B) (fun f : cart A B => forall i : N, ((N.le (NUMERAL (BIT1 N0)) i) /\ (N.le i (@dimindex B (@Ensembles.Full_set B)))) -> (@dollar A B f i) = (_94602 i))).
Proof. exact (eq_refl (@lambda A B)). Qed.
Definition pastecart {A M N' : Type'} : (cart A M) -> (cart A N') -> cart A (finite_sum M N') := fun _94893 : cart A M => fun _94894 : cart A N' => @lambda A (finite_sum M N') (fun i : N => @COND A (N.le i (@dimindex M (@Ensembles.Full_set M))) (@dollar A M _94893 i) (@dollar A N' _94894 (N.sub i (@dimindex M (@Ensembles.Full_set M))))).
Lemma pastecart_def {A M N' : Type'} : (@pastecart A M N') = (fun _94893 : cart A M => fun _94894 : cart A N' => @lambda A (finite_sum M N') (fun i : N => @COND A (N.le i (@dimindex M (@Ensembles.Full_set M))) (@dollar A M _94893 i) (@dollar A N' _94894 (N.sub i (@dimindex M (@Ensembles.Full_set M)))))).
Proof. exact (eq_refl (@pastecart A M N')). Qed.
Definition fstcart {A M N' : Type'} : (cart A (finite_sum M N')) -> cart A M := fun _94905 : cart A (finite_sum M N') => @lambda A M (fun i : N => @dollar A (finite_sum M N') _94905 i).
Lemma fstcart_def {A M N' : Type'} : (@fstcart A M N') = (fun _94905 : cart A (finite_sum M N') => @lambda A M (fun i : N => @dollar A (finite_sum M N') _94905 i)).
Proof. exact (eq_refl (@fstcart A M N')). Qed.
Definition sndcart {A M N' : Type'} : (cart A (finite_sum M N')) -> cart A N' := fun _94910 : cart A (finite_sum M N') => @lambda A N' (fun i : N => @dollar A (finite_sum M N') _94910 (N.add i (@dimindex M (@Ensembles.Full_set M)))).
Lemma sndcart_def {A M N' : Type'} : (@sndcart A M N') = (fun _94910 : cart A (finite_sum M N') => @lambda A N' (fun i : N => @dollar A (finite_sum M N') _94910 (N.add i (@dimindex M (@Ensembles.Full_set M))))).
Proof. exact (eq_refl (@sndcart A M N')). Qed.
Definition _100320 {A : Type'} : (finite_sum A A) -> tybit0 A := fun a : finite_sum A A => @_mk_tybit0 A ((fun a' : finite_sum A A => @CONSTR (finite_sum A A) (NUMERAL N0) a' (fun n : N => @BOTTOM (finite_sum A A))) a).
Lemma _100320_def {A : Type'} : (@_100320 A) = (fun a : finite_sum A A => @_mk_tybit0 A ((fun a' : finite_sum A A => @CONSTR (finite_sum A A) (NUMERAL N0) a' (fun n : N => @BOTTOM (finite_sum A A))) a)).
Proof. exact (eq_refl (@_100320 A)). Qed.
Definition mktybit0 {A : Type'} : (finite_sum A A) -> tybit0 A := @_100320 A.
Lemma mktybit0_def {A : Type'} : (@mktybit0 A) = (@_100320 A).
Proof. exact (eq_refl (@mktybit0 A)). Qed.
Definition _100339 {A : Type'} : (finite_sum (finite_sum A A) unit) -> tybit1 A := fun a : finite_sum (finite_sum A A) unit => @_mk_tybit1 A ((fun a' : finite_sum (finite_sum A A) unit => @CONSTR (finite_sum (finite_sum A A) unit) (NUMERAL N0) a' (fun n : N => @BOTTOM (finite_sum (finite_sum A A) unit))) a).
Lemma _100339_def {A : Type'} : (@_100339 A) = (fun a : finite_sum (finite_sum A A) unit => @_mk_tybit1 A ((fun a' : finite_sum (finite_sum A A) unit => @CONSTR (finite_sum (finite_sum A A) unit) (NUMERAL N0) a' (fun n : N => @BOTTOM (finite_sum (finite_sum A A) unit))) a)).
Proof. exact (eq_refl (@_100339 A)). Qed.
Definition mktybit1 {A : Type'} : (finite_sum (finite_sum A A) unit) -> tybit1 A := @_100339 A.
Lemma mktybit1_def {A : Type'} : (@mktybit1 A) = (@_100339 A).
Proof. exact (eq_refl (@mktybit1 A)). Qed.
Definition vector {A N' : Type'} : (list A) -> cart A N' := fun _102033 : list A => @lambda A N' (fun i : N => @Nth A (N.sub i (NUMERAL (BIT1 N0))) _102033).
Lemma vector_def {A N' : Type'} : (@vector A N') = (fun _102033 : list A => @lambda A N' (fun i : N => @Nth A (N.sub i (NUMERAL (BIT1 N0))) _102033)).
Proof. exact (eq_refl (@vector A N')). Qed.
Definition PCROSS {A M N' : Type'} : ((cart A M) -> Prop) -> ((cart A N') -> Prop) -> (cart A (finite_sum M N')) -> Prop := fun _102060 : (cart A M) -> Prop => fun _102061 : (cart A N') -> Prop => @GSPEC (cart A (finite_sum M N')) (fun GEN_PVAR_363 : cart A (finite_sum M N') => exists x : cart A M, exists y : cart A N', @SETSPEC (cart A (finite_sum M N')) GEN_PVAR_363 ((@IN (cart A M) x _102060) /\ (@IN (cart A N') y _102061)) (@pastecart A M N' x y)).
Lemma PCROSS_def {A M N' : Type'} : (@PCROSS A M N') = (fun _102060 : (cart A M) -> Prop => fun _102061 : (cart A N') -> Prop => @GSPEC (cart A (finite_sum M N')) (fun GEN_PVAR_363 : cart A (finite_sum M N') => exists x : cart A M, exists y : cart A N', @SETSPEC (cart A (finite_sum M N')) GEN_PVAR_363 ((@IN (cart A M) x _102060) /\ (@IN (cart A N') y _102061)) (@pastecart A M N' x y))).
Proof. exact (eq_refl (@PCROSS A M N')). Qed.
Definition CASEWISE {_137714 _137750 _137754 _137755 : Type'} : (list (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714))) -> _137755 -> _137754 -> _137714 := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> (list (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714))) -> _137755 -> _137754 -> _137714) (fun CASEWISE' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> (list (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714))) -> _137755 -> _137754 -> _137714 => forall _102665 : prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))), (forall f : _137755, forall x : _137754, (CASEWISE' _102665 (@nil (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714))) f x) = (@ε _137714 (fun y : _137714 => True))) /\ (forall h : prod (_137750 -> _137754) (_137755 -> _137750 -> _137714), forall t : list (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714)), forall f : _137755, forall x : _137754, (CASEWISE' _102665 (@cons (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714)) h t) f x) = (@COND _137714 (exists y : _137750, (@fst (_137750 -> _137754) (_137755 -> _137750 -> _137714) h y) = x) (@snd (_137750 -> _137754) (_137755 -> _137750 -> _137714) h f (@ε _137750 (fun y : _137750 => (@fst (_137750 -> _137754) (_137755 -> _137750 -> _137714) h y) = x))) (CASEWISE' _102665 t f x)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0))))))))))))))).
Lemma CASEWISE_def {_137714 _137750 _137754 _137755 : Type'} : (@CASEWISE _137714 _137750 _137754 _137755) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> (list (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714))) -> _137755 -> _137754 -> _137714) (fun CASEWISE' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> (list (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714))) -> _137755 -> _137754 -> _137714 => forall _102665 : prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))), (forall f : _137755, forall x : _137754, (CASEWISE' _102665 (@nil (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714))) f x) = (@ε _137714 (fun y : _137714 => True))) /\ (forall h : prod (_137750 -> _137754) (_137755 -> _137750 -> _137714), forall t : list (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714)), forall f : _137755, forall x : _137754, (CASEWISE' _102665 (@cons (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714)) h t) f x) = (@COND _137714 (exists y : _137750, (@fst (_137750 -> _137754) (_137755 -> _137750 -> _137714) h y) = x) (@snd (_137750 -> _137754) (_137755 -> _137750 -> _137714) h f (@ε _137750 (fun y : _137750 => (@fst (_137750 -> _137754) (_137755 -> _137750 -> _137714) h y) = x))) (CASEWISE' _102665 t f x)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))))))))))).
Proof. exact (eq_refl (@CASEWISE _137714 _137750 _137754 _137755)). Qed.
Definition admissible {_138045 _138048 _138052 _138053 _138058 : Type'} : (_138052 -> _138045 -> Prop) -> ((_138052 -> _138048) -> _138058 -> Prop) -> (_138058 -> _138045) -> ((_138052 -> _138048) -> _138058 -> _138053) -> Prop := fun _103732 : _138052 -> _138045 -> Prop => fun _103733 : (_138052 -> _138048) -> _138058 -> Prop => fun _103734 : _138058 -> _138045 => fun _103735 : (_138052 -> _138048) -> _138058 -> _138053 => forall f : _138052 -> _138048, forall g : _138052 -> _138048, forall a : _138058, ((_103733 f a) /\ ((_103733 g a) /\ (forall z : _138052, (_103732 z (_103734 a)) -> (f z) = (g z)))) -> (_103735 f a) = (_103735 g a).
Lemma admissible_def {_138045 _138048 _138052 _138053 _138058 : Type'} : (@admissible _138045 _138048 _138052 _138053 _138058) = (fun _103732 : _138052 -> _138045 -> Prop => fun _103733 : (_138052 -> _138048) -> _138058 -> Prop => fun _103734 : _138058 -> _138045 => fun _103735 : (_138052 -> _138048) -> _138058 -> _138053 => forall f : _138052 -> _138048, forall g : _138052 -> _138048, forall a : _138058, ((_103733 f a) /\ ((_103733 g a) /\ (forall z : _138052, (_103732 z (_103734 a)) -> (f z) = (g z)))) -> (_103735 f a) = (_103735 g a)).
Proof. exact (eq_refl (@admissible _138045 _138048 _138052 _138053 _138058)). Qed.
Definition tailadmissible {A B P : Type'} : (A -> A -> Prop) -> ((A -> B) -> P -> Prop) -> (P -> A) -> ((A -> B) -> P -> B) -> Prop := fun _103764 : A -> A -> Prop => fun _103765 : (A -> B) -> P -> Prop => fun _103766 : P -> A => fun _103767 : (A -> B) -> P -> B => exists P' : (A -> B) -> P -> Prop, exists G : (A -> B) -> P -> A, exists H : (A -> B) -> P -> B, (forall f : A -> B, forall a : P, forall y : A, ((P' f a) /\ (_103764 y (G f a))) -> _103764 y (_103766 a)) /\ ((forall f : A -> B, forall g : A -> B, forall a : P, (forall z : A, (_103764 z (_103766 a)) -> (f z) = (g z)) -> ((P' f a) = (P' g a)) /\ (((G f a) = (G g a)) /\ ((H f a) = (H g a)))) /\ (forall f : A -> B, forall a : P, (_103765 f a) -> (_103767 f a) = (@COND B (P' f a) (f (G f a)) (H f a)))).
Lemma tailadmissible_def {A B P : Type'} : (@tailadmissible A B P) = (fun _103764 : A -> A -> Prop => fun _103765 : (A -> B) -> P -> Prop => fun _103766 : P -> A => fun _103767 : (A -> B) -> P -> B => exists P' : (A -> B) -> P -> Prop, exists G : (A -> B) -> P -> A, exists H : (A -> B) -> P -> B, (forall f : A -> B, forall a : P, forall y : A, ((P' f a) /\ (_103764 y (G f a))) -> _103764 y (_103766 a)) /\ ((forall f : A -> B, forall g : A -> B, forall a : P, (forall z : A, (_103764 z (_103766 a)) -> (f z) = (g z)) -> ((P' f a) = (P' g a)) /\ (((G f a) = (G g a)) /\ ((H f a) = (H g a)))) /\ (forall f : A -> B, forall a : P, (_103765 f a) -> (_103767 f a) = (@COND B (P' f a) (f (G f a)) (H f a))))).
Proof. exact (eq_refl (@tailadmissible A B P)). Qed.
Definition superadmissible {_138202 _138204 _138210 : Type'} : (_138202 -> _138202 -> Prop) -> ((_138202 -> _138204) -> _138210 -> Prop) -> (_138210 -> _138202) -> ((_138202 -> _138204) -> _138210 -> _138204) -> Prop := fun _103796 : _138202 -> _138202 -> Prop => fun _103797 : (_138202 -> _138204) -> _138210 -> Prop => fun _103798 : _138210 -> _138202 => fun _103799 : (_138202 -> _138204) -> _138210 -> _138204 => (@admissible _138202 _138204 _138202 Prop _138210 _103796 (fun f : _138202 -> _138204 => fun a : _138210 => True) _103798 _103797) -> @tailadmissible _138202 _138204 _138210 _103796 _103797 _103798 _103799.
Lemma superadmissible_def {_138202 _138204 _138210 : Type'} : (@superadmissible _138202 _138204 _138210) = (fun _103796 : _138202 -> _138202 -> Prop => fun _103797 : (_138202 -> _138204) -> _138210 -> Prop => fun _103798 : _138210 -> _138202 => fun _103799 : (_138202 -> _138204) -> _138210 -> _138204 => (@admissible _138202 _138204 _138202 Prop _138210 _103796 (fun f : _138202 -> _138204 => fun a : _138210 => True) _103798 _103797) -> @tailadmissible _138202 _138204 _138210 _103796 _103797 _103798 _103799).
Proof. exact (eq_refl (@superadmissible _138202 _138204 _138210)). Qed.
Definition psum : (prod N N) -> (N -> R) -> R := @ε ((prod N (prod N (prod N N))) -> (prod N N) -> (N -> R) -> R) (fun sum' : (prod N (prod N (prod N N))) -> (prod N N) -> (N -> R) -> R => forall _114458 : prod N (prod N (prod N N)), (forall f : N -> R, forall n : N, (sum' _114458 (@pair N N n (NUMERAL N0)) f) = (R_of_N (NUMERAL N0))) /\ (forall f : N -> R, forall m : N, forall n : N, (sum' _114458 (@pair N N n (N.succ m)) f) = (Rplus (sum' _114458 (@pair N N n m) f) (f (N.add n m))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0))))))))))).
Lemma psum_def : psum = (@ε ((prod N (prod N (prod N N))) -> (prod N N) -> (N -> R) -> R) (fun sum' : (prod N (prod N (prod N N))) -> (prod N N) -> (N -> R) -> R => forall _114458 : prod N (prod N (prod N N)), (forall f : N -> R, forall n : N, (sum' _114458 (@pair N N n (NUMERAL N0)) f) = (R_of_N (NUMERAL N0))) /\ (forall f : N -> R, forall m : N, forall n : N, (sum' _114458 (@pair N N n (N.succ m)) f) = (Rplus (sum' _114458 (@pair N N n m) f) (f (N.add n m))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))))))).
Proof. exact (eq_refl psum). Qed.
Definition re_Union {A : Type'} : ((A -> Prop) -> Prop) -> A -> Prop := fun _114505 : (A -> Prop) -> Prop => fun x : A => exists s : A -> Prop, (_114505 s) /\ (s x).
Lemma re_Union_def {A : Type'} : (@re_Union A) = (fun _114505 : (A -> Prop) -> Prop => fun x : A => exists s : A -> Prop, (_114505 s) /\ (s x)).
Proof. exact (eq_refl (@re_Union A)). Qed.
Definition re_union {A : Type'} : (A -> Prop) -> (A -> Prop) -> A -> Prop := fun _114510 : A -> Prop => fun _114511 : A -> Prop => fun x : A => (_114510 x) \/ (_114511 x).
Lemma re_union_def {A : Type'} : (@re_union A) = (fun _114510 : A -> Prop => fun _114511 : A -> Prop => fun x : A => (_114510 x) \/ (_114511 x)).
Proof. exact (eq_refl (@re_union A)). Qed.
Definition re_intersect {A : Type'} : (A -> Prop) -> (A -> Prop) -> A -> Prop := fun _114522 : A -> Prop => fun _114523 : A -> Prop => fun x : A => (_114522 x) /\ (_114523 x).
Lemma re_intersect_def {A : Type'} : (@re_intersect A) = (fun _114522 : A -> Prop => fun _114523 : A -> Prop => fun x : A => (_114522 x) /\ (_114523 x)).
Proof. exact (eq_refl (@re_intersect A)). Qed.
Definition re_null {A : Type'} : A -> Prop := fun x : A => False.
Lemma re_null_def {A : Type'} : (@re_null A) = (fun x : A => False).
Proof. exact (eq_refl (@re_null A)). Qed.
Definition re_universe {A : Type'} : A -> Prop := fun x : A => True.
Lemma re_universe_def {A : Type'} : (@re_universe A) = (fun x : A => True).
Proof. exact (eq_refl (@re_universe A)). Qed.
Definition re_subset {A : Type'} : (A -> Prop) -> (A -> Prop) -> Prop := fun _114534 : A -> Prop => fun _114535 : A -> Prop => forall x : A, (_114534 x) -> _114535 x.
Lemma re_subset_def {A : Type'} : (@re_subset A) = (fun _114534 : A -> Prop => fun _114535 : A -> Prop => forall x : A, (_114534 x) -> _114535 x).
Proof. exact (eq_refl (@re_subset A)). Qed.
Definition re_compl {A : Type'} : (A -> Prop) -> A -> Prop := fun _114546 : A -> Prop => fun x : A => ~ (_114546 x).
Lemma re_compl_def {A : Type'} : (@re_compl A) = (fun _114546 : A -> Prop => fun x : A => ~ (_114546 x)).
Proof. exact (eq_refl (@re_compl A)). Qed.
Definition istopology {A : Type'} : ((A -> Prop) -> Prop) -> Prop := fun _114555 : (A -> Prop) -> Prop => (_114555 (@re_null A)) /\ ((_114555 (@re_universe A)) /\ ((forall a : A -> Prop, forall b : A -> Prop, ((_114555 a) /\ (_114555 b)) -> _114555 (@re_intersect A a b)) /\ (forall P : (A -> Prop) -> Prop, (@re_subset (A -> Prop) P _114555) -> _114555 (@re_Union A P)))).
Lemma istopology_def {A : Type'} : (@istopology A) = (fun _114555 : (A -> Prop) -> Prop => (_114555 (@re_null A)) /\ ((_114555 (@re_universe A)) /\ ((forall a : A -> Prop, forall b : A -> Prop, ((_114555 a) /\ (_114555 b)) -> _114555 (@re_intersect A a b)) /\ (forall P : (A -> Prop) -> Prop, (@re_subset (A -> Prop) P _114555) -> _114555 (@re_Union A P))))).
Proof. exact (eq_refl (@istopology A)). Qed.
Axiom _open : forall {A : Type'}, (Topology A) -> (A -> Prop) -> Prop.
Definition neigh {A : Type'} : (Topology A) -> (prod (A -> Prop) A) -> Prop := fun _114568 : Topology A => fun _114569 : prod (A -> Prop) A => exists P : A -> Prop, (@_open A _114568 P) /\ ((@re_subset A P (@fst (A -> Prop) A _114569)) /\ (P (@snd (A -> Prop) A _114569))).
Lemma neigh_def {A : Type'} : (@neigh A) = (fun _114568 : Topology A => fun _114569 : prod (A -> Prop) A => exists P : A -> Prop, (@_open A _114568 P) /\ ((@re_subset A P (@fst (A -> Prop) A _114569)) /\ (P (@snd (A -> Prop) A _114569)))).
Proof. exact (eq_refl (@neigh A)). Qed.
Definition closed {A : Type'} : (Topology A) -> (A -> Prop) -> Prop := fun _114589 : Topology A => fun _114590 : A -> Prop => @_open A _114589 (@re_compl A _114590).
Lemma closed_def {A : Type'} : (@closed A) = (fun _114589 : Topology A => fun _114590 : A -> Prop => @_open A _114589 (@re_compl A _114590)).
Proof. exact (eq_refl (@closed A)). Qed.
Definition limpt {A : Type'} : (Topology A) -> A -> (A -> Prop) -> Prop := fun _114601 : Topology A => fun _114602 : A => fun _114603 : A -> Prop => forall N' : A -> Prop, (@neigh A _114601 (@pair (A -> Prop) A N' _114602)) -> exists y : A, (~ (_114602 = y)) /\ ((_114603 y) /\ (N' y)).
Lemma limpt_def {A : Type'} : (@limpt A) = (fun _114601 : Topology A => fun _114602 : A => fun _114603 : A -> Prop => forall N' : A -> Prop, (@neigh A _114601 (@pair (A -> Prop) A N' _114602)) -> exists y : A, (~ (_114602 = y)) /\ ((_114603 y) /\ (N' y))).
Proof. exact (eq_refl (@limpt A)). Qed.
Definition mtop {A : Type'} : (Metric A) -> Topology A := fun _114749 : Metric A => @topology A (fun S' : A -> Prop => forall x : A, (S' x) -> exists e : R, (Rlt (R_of_N (NUMERAL N0)) e) /\ (forall y : A, (Rlt (@mdist A _114749 (@pair A A x y)) e) -> S' y)).
Lemma mtop_def {A : Type'} : (@mtop A) = (fun _114749 : Metric A => @topology A (fun S' : A -> Prop => forall x : A, (S' x) -> exists e : R, (Rlt (R_of_N (NUMERAL N0)) e) /\ (forall y : A, (Rlt (@mdist A _114749 (@pair A A x y)) e) -> S' y))).
Proof. exact (eq_refl (@mtop A)). Qed.
Definition ball {A : Type'} : (Metric A) -> (prod A R) -> A -> Prop := fun _114760 : Metric A => fun _114761 : prod A R => fun y : A => Rlt (@mdist A _114760 (@pair A A (@fst A R _114761) y)) (@snd A R _114761).
Lemma ball_def {A : Type'} : (@ball A) = (fun _114760 : Metric A => fun _114761 : prod A R => fun y : A => Rlt (@mdist A _114760 (@pair A A (@fst A R _114761) y)) (@snd A R _114761)).
Proof. exact (eq_refl (@ball A)). Qed.
Definition mr1 : Metric R := @metric R (@ε ((prod R R) -> R) (fun f : (prod R R) -> R => forall x : R, forall y : R, @eq R (f (@pair R R x y)) (Rabs (Rminus y x)))).
Lemma mr1_def : mr1 = (@metric R (@ε ((prod R R) -> R) (fun f : (prod R R) -> R => forall x : R, forall y : R, @eq R (f (@pair R R x y)) (Rabs (Rminus y x))))).
Proof. exact (eq_refl mr1). Qed.
Definition dorder {A : Type'} : (A -> A -> Prop) -> Prop := fun _114842 : A -> A -> Prop => forall x : A, forall y : A, ((_114842 x x) /\ (_114842 y y)) -> exists z : A, (_114842 z z) /\ (forall w : A, (_114842 w z) -> (_114842 w x) /\ (_114842 w y)).
Lemma dorder_def {A : Type'} : (@dorder A) = (fun _114842 : A -> A -> Prop => forall x : A, forall y : A, ((_114842 x x) /\ (_114842 y y)) -> exists z : A, (_114842 z z) /\ (forall w : A, (_114842 w z) -> (_114842 w x) /\ (_114842 w y))).
Proof. exact (eq_refl (@dorder A)). Qed.
Definition tends {A B : Type'} : (B -> A) -> A -> (prod (Topology A) (B -> B -> Prop)) -> Prop := fun _114847 : B -> A => fun _114848 : A => fun _114849 : prod (Topology A) (B -> B -> Prop) => forall N' : A -> Prop, (@neigh A (@fst (Topology A) (B -> B -> Prop) _114849) (@pair (A -> Prop) A N' _114848)) -> exists n : B, (@snd (Topology A) (B -> B -> Prop) _114849 n n) /\ (forall m : B, (@snd (Topology A) (B -> B -> Prop) _114849 m n) -> N' (_114847 m)).
Lemma tends_def {A B : Type'} : (@tends A B) = (fun _114847 : B -> A => fun _114848 : A => fun _114849 : prod (Topology A) (B -> B -> Prop) => forall N' : A -> Prop, (@neigh A (@fst (Topology A) (B -> B -> Prop) _114849) (@pair (A -> Prop) A N' _114848)) -> exists n : B, (@snd (Topology A) (B -> B -> Prop) _114849 n n) /\ (forall m : B, (@snd (Topology A) (B -> B -> Prop) _114849 m n) -> N' (_114847 m))).
Proof. exact (eq_refl (@tends A B)). Qed.
Definition bounded {A B : Type'} : (prod (Metric A) (B -> B -> Prop)) -> (B -> A) -> Prop := fun _114874 : prod (Metric A) (B -> B -> Prop) => fun _114875 : B -> A => exists k : R, exists x : A, exists N' : B, (@snd (Metric A) (B -> B -> Prop) _114874 N' N') /\ (forall n : B, (@snd (Metric A) (B -> B -> Prop) _114874 n N') -> Rlt (@mdist A (@fst (Metric A) (B -> B -> Prop) _114874) (@pair A A (_114875 n) x)) k).
Lemma bounded_def {A B : Type'} : (@bounded A B) = (fun _114874 : prod (Metric A) (B -> B -> Prop) => fun _114875 : B -> A => exists k : R, exists x : A, exists N' : B, (@snd (Metric A) (B -> B -> Prop) _114874 N' N') /\ (forall n : B, (@snd (Metric A) (B -> B -> Prop) _114874 n N') -> Rlt (@mdist A (@fst (Metric A) (B -> B -> Prop) _114874) (@pair A A (_114875 n) x)) k)).
Proof. exact (eq_refl (@bounded A B)). Qed.
Definition tendsto {A : Type'} : (prod (Metric A) A) -> A -> A -> Prop := fun _114891 : prod (Metric A) A => fun _114892 : A => fun _114893 : A => (Rlt (R_of_N (NUMERAL N0)) (@mdist A (@fst (Metric A) A _114891) (@pair A A (@snd (Metric A) A _114891) _114892))) /\ (Rle (@mdist A (@fst (Metric A) A _114891) (@pair A A (@snd (Metric A) A _114891) _114892)) (@mdist A (@fst (Metric A) A _114891) (@pair A A (@snd (Metric A) A _114891) _114893))).
Lemma tendsto_def {A : Type'} : (@tendsto A) = (fun _114891 : prod (Metric A) A => fun _114892 : A => fun _114893 : A => (Rlt (R_of_N (NUMERAL N0)) (@mdist A (@fst (Metric A) A _114891) (@pair A A (@snd (Metric A) A _114891) _114892))) /\ (Rle (@mdist A (@fst (Metric A) A _114891) (@pair A A (@snd (Metric A) A _114891) _114892)) (@mdist A (@fst (Metric A) A _114891) (@pair A A (@snd (Metric A) A _114891) _114893)))).
Proof. exact (eq_refl (@tendsto A)). Qed.
Definition tends_num_real : (N -> R) -> R -> Prop := fun _114982 : N -> R => fun _114983 : R => @tends R N _114982 _114983 (@pair (Topology R) (N -> N -> Prop) (@mtop R mr1) N.ge).
Lemma tends_num_real_def : tends_num_real = (fun _114982 : N -> R => fun _114983 : R => @tends R N _114982 _114983 (@pair (Topology R) (N -> N -> Prop) (@mtop R mr1) N.ge)).
Proof. exact (eq_refl tends_num_real). Qed.
Definition convergent : (N -> R) -> Prop := fun _115038 : N -> R => exists l : R, tends_num_real _115038 l.
Lemma convergent_def : convergent = (fun _115038 : N -> R => exists l : R, tends_num_real _115038 l).
Proof. exact (eq_refl convergent). Qed.
Definition cauchy : (N -> R) -> Prop := fun _115043 : N -> R => forall e : R, (Rlt (R_of_N (NUMERAL N0)) e) -> exists N' : N, forall m : N, forall n : N, ((N.ge m N') /\ (N.ge n N')) -> Rlt (Rabs (Rminus (_115043 m) (_115043 n))) e.
Lemma cauchy_def : cauchy = (fun _115043 : N -> R => forall e : R, (Rlt (R_of_N (NUMERAL N0)) e) -> exists N' : N, forall m : N, forall n : N, ((N.ge m N') /\ (N.ge n N')) -> Rlt (Rabs (Rminus (_115043 m) (_115043 n))) e).
Proof. exact (eq_refl cauchy). Qed.
Definition lim : (N -> R) -> R := fun _115048 : N -> R => @ε R (fun l : R => tends_num_real _115048 l).
Lemma lim_def : lim = (fun _115048 : N -> R => @ε R (fun l : R => tends_num_real _115048 l)).
Proof. exact (eq_refl lim). Qed.
Definition subseq : (N -> N) -> Prop := fun _115053 : N -> N => forall m : N, forall n : N, (N.lt m n) -> N.lt (_115053 m) (_115053 n).
Lemma subseq_def : subseq = (fun _115053 : N -> N => forall m : N, forall n : N, (N.lt m n) -> N.lt (_115053 m) (_115053 n)).
Proof. exact (eq_refl subseq). Qed.
Definition mono : (N -> R) -> Prop := fun _115060 : N -> R => (forall m : N, forall n : N, (N.le m n) -> Rle (_115060 m) (_115060 n)) \/ (forall m : N, forall n : N, (N.le m n) -> Rge (_115060 m) (_115060 n)).
Lemma mono_def : mono = (fun _115060 : N -> R => (forall m : N, forall n : N, (N.le m n) -> Rle (_115060 m) (_115060 n)) \/ (forall m : N, forall n : N, (N.le m n) -> Rge (_115060 m) (_115060 n))).
Proof. exact (eq_refl mono). Qed.
Definition sums : (N -> R) -> R -> Prop := fun _115340 : N -> R => fun _115341 : R => tends_num_real (fun n : N => psum (@pair N N (NUMERAL N0) n) _115340) _115341.
Lemma sums_def : sums = (fun _115340 : N -> R => fun _115341 : R => tends_num_real (fun n : N => psum (@pair N N (NUMERAL N0) n) _115340) _115341).
Proof. exact (eq_refl sums). Qed.
Definition summable : (N -> R) -> Prop := fun _115352 : N -> R => exists s : R, sums _115352 s.
Lemma summable_def : summable = (fun _115352 : N -> R => exists s : R, sums _115352 s).
Proof. exact (eq_refl summable). Qed.
Definition suminf : (N -> R) -> R := fun _115357 : N -> R => @ε R (fun s : R => sums _115357 s).
Lemma suminf_def : suminf = (fun _115357 : N -> R => @ε R (fun s : R => sums _115357 s)).
Proof. exact (eq_refl suminf). Qed.
Definition tends_real_real : (R -> R) -> R -> R -> Prop := fun _115425 : R -> R => fun _115426 : R => fun _115427 : R => @tends R R _115425 _115426 (@pair (Topology R) (R -> R -> Prop) (@mtop R mr1) (@tendsto R (@pair (Metric R) R mr1 _115427))).
Lemma tends_real_real_def : tends_real_real = (fun _115425 : R -> R => fun _115426 : R => fun _115427 : R => @tends R R _115425 _115426 (@pair (Topology R) (R -> R -> Prop) (@mtop R mr1) (@tendsto R (@pair (Metric R) R mr1 _115427)))).
Proof. exact (eq_refl tends_real_real). Qed.
Definition diffl : (R -> R) -> R -> R -> Prop := fun _115455 : R -> R => fun _115456 : R => fun _115457 : R => tends_real_real (fun h : R => Rdiv (Rminus (_115455 (Rplus _115457 h)) (_115455 _115457)) h) _115456 (R_of_N (NUMERAL N0)).
Lemma diffl_def : diffl = (fun _115455 : R -> R => fun _115456 : R => fun _115457 : R => tends_real_real (fun h : R => Rdiv (Rminus (_115455 (Rplus _115457 h)) (_115455 _115457)) h) _115456 (R_of_N (NUMERAL N0))).
Proof. exact (eq_refl diffl). Qed.
Definition contl : (R -> R) -> R -> Prop := fun _115476 : R -> R => fun _115477 : R => tends_real_real (fun h : R => _115476 (Rplus _115477 h)) (_115476 _115477) (R_of_N (NUMERAL N0)).
Lemma contl_def : contl = (fun _115476 : R -> R => fun _115477 : R => tends_real_real (fun h : R => _115476 (Rplus _115477 h)) (_115476 _115477) (R_of_N (NUMERAL N0))).
Proof. exact (eq_refl contl). Qed.
Definition differentiable : (R -> R) -> R -> Prop := fun _115488 : R -> R => fun _115489 : R => exists l : R, diffl _115488 l _115489.
Lemma differentiable_def : differentiable = (fun _115488 : R -> R => fun _115489 : R => exists l : R, diffl _115488 l _115489).
Proof. exact (eq_refl differentiable). Qed.
Definition fld {A : Type'} : (A -> A -> Prop) -> A -> Prop := fun _117619 : A -> A -> Prop => @GSPEC A (fun GEN_PVAR_377 : A => exists x : A, @SETSPEC A GEN_PVAR_377 (exists y : A, (_117619 x y) \/ (_117619 y x)) x).
Lemma fld_def {A : Type'} : (@fld A) = (fun _117619 : A -> A -> Prop => @GSPEC A (fun GEN_PVAR_377 : A => exists x : A, @SETSPEC A GEN_PVAR_377 (exists y : A, (_117619 x y) \/ (_117619 y x)) x)).
Proof. exact (eq_refl (@fld A)). Qed.
Definition qoset {A : Type'} : (A -> A -> Prop) -> Prop := fun _117674 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117674)) -> _117674 x x) /\ (forall x : A, forall y : A, forall z : A, ((_117674 x y) /\ (_117674 y z)) -> _117674 x z).
Lemma qoset_def {A : Type'} : (@qoset A) = (fun _117674 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117674)) -> _117674 x x) /\ (forall x : A, forall y : A, forall z : A, ((_117674 x y) /\ (_117674 y z)) -> _117674 x z)).
Proof. exact (eq_refl (@qoset A)). Qed.
Definition poset {A : Type'} : (A -> A -> Prop) -> Prop := fun _117679 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117679)) -> _117679 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117679 x y) /\ (_117679 y z)) -> _117679 x z) /\ (forall x : A, forall y : A, ((_117679 x y) /\ (_117679 y x)) -> x = y)).
Lemma poset_def {A : Type'} : (@poset A) = (fun _117679 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117679)) -> _117679 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117679 x y) /\ (_117679 y z)) -> _117679 x z) /\ (forall x : A, forall y : A, ((_117679 x y) /\ (_117679 y x)) -> x = y))).
Proof. exact (eq_refl (@poset A)). Qed.
Definition toset {A : Type'} : (A -> A -> Prop) -> Prop := fun _117684 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117684)) -> _117684 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117684 x y) /\ (_117684 y z)) -> _117684 x z) /\ ((forall x : A, forall y : A, ((_117684 x y) /\ (_117684 y x)) -> x = y) /\ (forall x : A, forall y : A, ((@IN A x (@fld A _117684)) /\ (@IN A y (@fld A _117684))) -> (_117684 x y) \/ (_117684 y x)))).
Lemma toset_def {A : Type'} : (@toset A) = (fun _117684 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117684)) -> _117684 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117684 x y) /\ (_117684 y z)) -> _117684 x z) /\ ((forall x : A, forall y : A, ((_117684 x y) /\ (_117684 y x)) -> x = y) /\ (forall x : A, forall y : A, ((@IN A x (@fld A _117684)) /\ (@IN A y (@fld A _117684))) -> (_117684 x y) \/ (_117684 y x))))).
Proof. exact (eq_refl (@toset A)). Qed.
Definition woset {A : Type'} : (A -> A -> Prop) -> Prop := fun _117689 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117689)) -> _117689 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117689 x y) /\ (_117689 y z)) -> _117689 x z) /\ ((forall x : A, forall y : A, ((_117689 x y) /\ (_117689 y x)) -> x = y) /\ ((forall x : A, forall y : A, ((@IN A x (@fld A _117689)) /\ (@IN A y (@fld A _117689))) -> (_117689 x y) \/ (_117689 y x)) /\ (forall s : A -> Prop, ((@Ensembles.Included A s (@fld A _117689)) /\ (~ (s = (@Ensembles.Empty_set A)))) -> exists x : A, (@IN A x s) /\ (forall y : A, (@IN A y s) -> _117689 x y))))).
Lemma woset_def {A : Type'} : (@woset A) = (fun _117689 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117689)) -> _117689 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117689 x y) /\ (_117689 y z)) -> _117689 x z) /\ ((forall x : A, forall y : A, ((_117689 x y) /\ (_117689 y x)) -> x = y) /\ ((forall x : A, forall y : A, ((@IN A x (@fld A _117689)) /\ (@IN A y (@fld A _117689))) -> (_117689 x y) \/ (_117689 y x)) /\ (forall s : A -> Prop, ((@Ensembles.Included A s (@fld A _117689)) /\ (~ (s = (@Ensembles.Empty_set A)))) -> exists x : A, (@IN A x s) /\ (forall y : A, (@IN A y s) -> _117689 x y)))))).
Proof. exact (eq_refl (@woset A)). Qed.
Definition wqoset {A : Type'} : (A -> A -> Prop) -> Prop := fun _117694 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117694)) -> _117694 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117694 x y) /\ (_117694 y z)) -> _117694 x z) /\ (forall s : A -> Prop, (@Ensembles.Included A s (@fld A _117694)) -> exists t : A -> Prop, (@FINITE A t) /\ ((@Ensembles.Included A t s) /\ (forall y : A, (@IN A y s) -> exists x : A, (@IN A x t) /\ (_117694 x y))))).
Lemma wqoset_def {A : Type'} : (@wqoset A) = (fun _117694 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117694)) -> _117694 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117694 x y) /\ (_117694 y z)) -> _117694 x z) /\ (forall s : A -> Prop, (@Ensembles.Included A s (@fld A _117694)) -> exists t : A -> Prop, (@FINITE A t) /\ ((@Ensembles.Included A t s) /\ (forall y : A, (@IN A y s) -> exists x : A, (@IN A x t) /\ (_117694 x y)))))).
Proof. exact (eq_refl (@wqoset A)). Qed.
Definition chain {A : Type'} : (A -> A -> Prop) -> (A -> Prop) -> Prop := fun _117699 : A -> A -> Prop => fun _117700 : A -> Prop => forall x : A, forall y : A, ((@IN A x _117700) /\ (@IN A y _117700)) -> (_117699 x y) \/ (_117699 y x).
Lemma chain_def {A : Type'} : (@chain A) = (fun _117699 : A -> A -> Prop => fun _117700 : A -> Prop => forall x : A, forall y : A, ((@IN A x _117700) /\ (@IN A y _117700)) -> (_117699 x y) \/ (_117699 y x)).
Proof. exact (eq_refl (@chain A)). Qed.
Definition antichain {A : Type'} : (A -> A -> Prop) -> (A -> Prop) -> Prop := fun _117711 : A -> A -> Prop => fun _117712 : A -> Prop => (@Ensembles.Included A _117712 (@fld A _117711)) /\ (@pairwise A (fun x : A => fun y : A => ~ (_117711 x y)) _117712).
Lemma antichain_def {A : Type'} : (@antichain A) = (fun _117711 : A -> A -> Prop => fun _117712 : A -> Prop => (@Ensembles.Included A _117712 (@fld A _117711)) /\ (@pairwise A (fun x : A => fun y : A => ~ (_117711 x y)) _117712)).
Proof. exact (eq_refl (@antichain A)). Qed.
Definition strictly {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _118364 : A -> A -> Prop => fun x : A => fun y : A => (_118364 x y) /\ (~ (_118364 y x)).
Lemma strictly_def {A : Type'} : (@strictly A) = (fun _118364 : A -> A -> Prop => fun x : A => fun y : A => (_118364 x y) /\ (~ (_118364 y x))).
Proof. exact (eq_refl (@strictly A)). Qed.
Definition properly {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _118369 : A -> A -> Prop => fun x : A => fun y : A => (_118369 x y) /\ (~ (x = y)).
Lemma properly_def {A : Type'} : (@properly A) = (fun _118369 : A -> A -> Prop => fun x : A => fun y : A => (_118369 x y) /\ (~ (x = y))).
Proof. exact (eq_refl (@properly A)). Qed.
Definition inseg {A : Type'} : (A -> A -> Prop) -> (A -> A -> Prop) -> Prop := fun _122630 : A -> A -> Prop => fun _122631 : A -> A -> Prop => forall x : A, forall y : A, (_122630 x y) = ((_122631 x y) /\ (@fld A _122630 y)).
Lemma inseg_def {A : Type'} : (@inseg A) = (fun _122630 : A -> A -> Prop => fun _122631 : A -> A -> Prop => forall x : A, forall y : A, (_122630 x y) = ((_122631 x y) /\ (@fld A _122630 y))).
Proof. exact (eq_refl (@inseg A)). Qed.
Definition linseg {A : Type'} : (A -> A -> Prop) -> A -> A -> A -> Prop := fun _122702 : A -> A -> Prop => fun _122703 : A => fun x : A => fun y : A => (_122702 x y) /\ (@properly A _122702 y _122703).
Lemma linseg_def {A : Type'} : (@linseg A) = (fun _122702 : A -> A -> Prop => fun _122703 : A => fun x : A => fun y : A => (_122702 x y) /\ (@properly A _122702 y _122703)).
Proof. exact (eq_refl (@linseg A)). Qed.
Definition ordinal {A : Type'} : (A -> A -> Prop) -> Prop := fun _122714 : A -> A -> Prop => (@woset A _122714) /\ (forall x : A, (@fld A _122714 x) -> x = (@ε A (fun y : A => ~ (@properly A _122714 y x)))).
Lemma ordinal_def {A : Type'} : (@ordinal A) = (fun _122714 : A -> A -> Prop => (@woset A _122714) /\ (forall x : A, (@fld A _122714 x) -> x = (@ε A (fun y : A => ~ (@properly A _122714 y x))))).
Proof. exact (eq_refl (@ordinal A)). Qed.
Definition RC {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun R' : A -> A -> Prop => fun a0 : A => fun a1 : A => forall RC' : A -> A -> Prop, (forall a0' : A, forall a1' : A, ((R' a0' a1') \/ (a1' = a0')) -> RC' a0' a1') -> RC' a0 a1.
Lemma RC_def {A : Type'} : (@RC A) = (fun R' : A -> A -> Prop => fun a0 : A => fun a1 : A => forall RC' : A -> A -> Prop, (forall a0' : A, forall a1' : A, ((R' a0' a1') \/ (a1' = a0')) -> RC' a0' a1') -> RC' a0 a1).
Proof. exact (eq_refl (@RC A)). Qed.
Definition SC {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun R' : A -> A -> Prop => fun a0 : A => fun a1 : A => forall SC' : A -> A -> Prop, (forall a0' : A, forall a1' : A, ((R' a0' a1') \/ (SC' a1' a0')) -> SC' a0' a1') -> SC' a0 a1.
Lemma SC_def {A : Type'} : (@SC A) = (fun R' : A -> A -> Prop => fun a0 : A => fun a1 : A => forall SC' : A -> A -> Prop, (forall a0' : A, forall a1' : A, ((R' a0' a1') \/ (SC' a1' a0')) -> SC' a0' a1') -> SC' a0 a1).
Proof. exact (eq_refl (@SC A)). Qed.
Definition RSC {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _198680 : A -> A -> Prop => @RC A (@SC A _198680).
Lemma RSC_def {A : Type'} : (@RSC A) = (fun _198680 : A -> A -> Prop => @RC A (@SC A _198680)).
Proof. exact (eq_refl (@RSC A)). Qed.
Definition RTC {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _198804 : A -> A -> Prop => @RC A (@Relation_Operators.clos_trans A _198804).
Lemma RTC_def {A : Type'} : (@RTC A) = (fun _198804 : A -> A -> Prop => @RC A (@Relation_Operators.clos_trans A _198804)).
Proof. exact (eq_refl (@RTC A)). Qed.
Definition STC {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _200315 : A -> A -> Prop => @Relation_Operators.clos_trans A (@SC A _200315).
Lemma STC_def {A : Type'} : (@STC A) = (fun _200315 : A -> A -> Prop => @Relation_Operators.clos_trans A (@SC A _200315)).
Proof. exact (eq_refl (@STC A)). Qed.
Definition RSTC {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _200607 : A -> A -> Prop => @RC A (@Relation_Operators.clos_trans A (@SC A _200607)).
Lemma RSTC_def {A : Type'} : (@RSTC A) = (fun _200607 : A -> A -> Prop => @RC A (@Relation_Operators.clos_trans A (@SC A _200607))).
Proof. exact (eq_refl (@RSTC A)). Qed.
Definition INV {A B : Type'} : (B -> A -> Prop) -> A -> B -> Prop := fun _201552 : B -> A -> Prop => fun _201553 : A => fun _201554 : B => _201552 _201554 _201553.
Lemma INV_def {A B : Type'} : (@INV A B) = (fun _201552 : B -> A -> Prop => fun _201553 : A => fun _201554 : B => _201552 _201554 _201553).
Proof. exact (eq_refl (@INV A B)). Qed.
Definition RELPOW {A : Type'} : N -> (A -> A -> Prop) -> A -> A -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N N))))) -> N -> (A -> A -> Prop) -> A -> A -> Prop) (fun RELPOW' : (prod N (prod N (prod N (prod N (prod N N))))) -> N -> (A -> A -> Prop) -> A -> A -> Prop => forall _201628 : prod N (prod N (prod N (prod N (prod N N)))), (forall R' : A -> A -> Prop, forall x : A, forall y : A, (RELPOW' _201628 (NUMERAL N0) R' x y) = (x = y)) /\ (forall n : N, forall x : A, forall R' : A -> A -> Prop, forall y : A, (RELPOW' _201628 (N.succ n) R' x y) = (exists z : A, (RELPOW' _201628 n R' x z) /\ (R' z y)))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0))))))))))))).
Lemma RELPOW_def {A : Type'} : (@RELPOW A) = (@ε ((prod N (prod N (prod N (prod N (prod N N))))) -> N -> (A -> A -> Prop) -> A -> A -> Prop) (fun RELPOW' : (prod N (prod N (prod N (prod N (prod N N))))) -> N -> (A -> A -> Prop) -> A -> A -> Prop => forall _201628 : prod N (prod N (prod N (prod N (prod N N)))), (forall R' : A -> A -> Prop, forall x : A, forall y : A, (RELPOW' _201628 (NUMERAL N0) R' x y) = (x = y)) /\ (forall n : N, forall x : A, forall R' : A -> A -> Prop, forall y : A, (RELPOW' _201628 (N.succ n) R' x y) = (exists z : A, (RELPOW' _201628 n R' x z) /\ (R' z y)))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))))))))).
Proof. exact (eq_refl (@RELPOW A)). Qed.
Definition NORMAL {A : Type'} : (A -> A -> Prop) -> A -> Prop := fun _202286 : A -> A -> Prop => fun _202287 : A => ~ (exists y : A, _202286 _202287 y).
Lemma NORMAL_def {A : Type'} : (@NORMAL A) = (fun _202286 : A -> A -> Prop => fun _202287 : A => ~ (exists y : A, _202286 _202287 y)).
Proof. exact (eq_refl (@NORMAL A)). Qed.
Definition CR {A : Type'} : (A -> A -> Prop) -> Prop := fun _202298 : A -> A -> Prop => forall x : A, forall y1 : A, forall y2 : A, ((_202298 x y1) /\ (_202298 x y2)) -> exists z : A, (_202298 y1 z) /\ (_202298 y2 z).
Lemma CR_def {A : Type'} : (@CR A) = (fun _202298 : A -> A -> Prop => forall x : A, forall y1 : A, forall y2 : A, ((_202298 x y1) /\ (_202298 x y2)) -> exists z : A, (_202298 y1 z) /\ (_202298 y2 z)).
Proof. exact (eq_refl (@CR A)). Qed.
Definition WCR {A : Type'} : (A -> A -> Prop) -> Prop := fun _202303 : A -> A -> Prop => forall x : A, forall y1 : A, forall y2 : A, ((_202303 x y1) /\ (_202303 x y2)) -> exists z : A, (@RTC A _202303 y1 z) /\ (@RTC A _202303 y2 z).
Lemma WCR_def {A : Type'} : (@WCR A) = (fun _202303 : A -> A -> Prop => forall x : A, forall y1 : A, forall y2 : A, ((_202303 x y1) /\ (_202303 x y2)) -> exists z : A, (@RTC A _202303 y1 z) /\ (@RTC A _202303 y2 z)).
Proof. exact (eq_refl (@WCR A)). Qed.
Definition WN {A : Type'} : (A -> A -> Prop) -> Prop := fun _202308 : A -> A -> Prop => forall x : A, exists y : A, (@RTC A _202308 x y) /\ (@NORMAL A _202308 y).
Lemma WN_def {A : Type'} : (@WN A) = (fun _202308 : A -> A -> Prop => forall x : A, exists y : A, (@RTC A _202308 x y) /\ (@NORMAL A _202308 y)).
Proof. exact (eq_refl (@WN A)). Qed.
Definition SN {A : Type'} : (A -> A -> Prop) -> Prop := fun _202313 : A -> A -> Prop => ~ (exists seq : N -> A, forall n : N, _202313 (seq n) (seq (N.succ n))).
Lemma SN_def {A : Type'} : (@SN A) = (fun _202313 : A -> A -> Prop => ~ (exists seq : N -> A, forall n : N, _202313 (seq n) (seq (N.succ n)))).
Proof. exact (eq_refl (@SN A)). Qed.
Definition TREE {A : Type'} : (A -> A -> Prop) -> Prop := fun _202318 : A -> A -> Prop => (forall y : A, ~ (@Relation_Operators.clos_trans A _202318 y y)) /\ (exists a : A, (@IN A a (@fld A _202318)) /\ (forall y : A, (@IN A y (@fld A _202318)) -> (y = a) \/ ((@Relation_Operators.clos_trans A _202318 a y) /\ (@ex1 A (fun x : A => _202318 x y))))).
Lemma TREE_def {A : Type'} : (@TREE A) = (fun _202318 : A -> A -> Prop => (forall y : A, ~ (@Relation_Operators.clos_trans A _202318 y y)) /\ (exists a : A, (@IN A a (@fld A _202318)) /\ (forall y : A, (@IN A y (@fld A _202318)) -> (y = a) \/ ((@Relation_Operators.clos_trans A _202318 a y) /\ (@ex1 A (fun x : A => _202318 x y)))))).
Proof. exact (eq_refl (@TREE A)). Qed.
Definition LF {A : Type'} : (A -> A -> Prop) -> Prop := fun _202323 : A -> A -> Prop => forall x : A, @FINITE A (@GSPEC A (fun GEN_PVAR_407 : A => exists y : A, @SETSPEC A GEN_PVAR_407 (_202323 x y) y)).
Lemma LF_def {A : Type'} : (@LF A) = (fun _202323 : A -> A -> Prop => forall x : A, @FINITE A (@GSPEC A (fun GEN_PVAR_407 : A => exists y : A, @SETSPEC A GEN_PVAR_407 (_202323 x y) y))).
Proof. exact (eq_refl (@LF A)). Qed.
Definition JOINABLE {_183261 : Type'} : (_183261 -> _183261 -> Prop) -> _183261 -> _183261 -> Prop := fun _203860 : _183261 -> _183261 -> Prop => fun _203861 : _183261 => fun _203862 : _183261 => exists u : _183261, (@RTC _183261 _203860 _203861 u) /\ (@RTC _183261 _203860 _203862 u).
Lemma JOINABLE_def {_183261 : Type'} : (@JOINABLE _183261) = (fun _203860 : _183261 -> _183261 -> Prop => fun _203861 : _183261 => fun _203862 : _183261 => exists u : _183261, (@RTC _183261 _203860 _203861 u) /\ (@RTC _183261 _203860 _203862 u)).
Proof. exact (eq_refl (@JOINABLE _183261)). Qed.
Definition DOWNFROM : N -> list N := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> N -> list N) (fun DOWNFROM' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> N -> list N => forall _232647 : prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))), ((DOWNFROM' _232647 (NUMERAL N0)) = (@nil N)) /\ (forall n : N, (DOWNFROM' _232647 (N.succ n)) = (@cons N n (DOWNFROM' _232647 n)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0))))))))))))))).
Lemma DOWNFROM_def : DOWNFROM = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> N -> list N) (fun DOWNFROM' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> N -> list N => forall _232647 : prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))), ((DOWNFROM' _232647 (NUMERAL N0)) = (@nil N)) /\ (forall n : N, (DOWNFROM' _232647 (N.succ n)) = (@cons N n (DOWNFROM' _232647 n)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))))))))))).
Proof. exact (eq_refl DOWNFROM). Qed.
Definition loopcheck : (list (prod N term)) -> N -> term -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (list (prod N term)) -> N -> term -> Prop) (fun loopcheck' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (list (prod N term)) -> N -> term -> Prop => forall _260232 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))), forall env : list (prod N term), forall x : N, (LOOPFREE env) -> forall t : term, (loopcheck' _260232 env x t) = (exists y : N, (@IN N y (free_variables_term t)) /\ ((y = x) \/ (exists s : term, (@List.In (prod N term) (@pair N term y s) env) /\ (loopcheck' _260232 env x s))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))))))))))).
Lemma loopcheck_def : loopcheck = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (list (prod N term)) -> N -> term -> Prop) (fun loopcheck' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (list (prod N term)) -> N -> term -> Prop => forall _260232 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))), forall env : list (prod N term), forall x : N, (LOOPFREE env) -> forall t : term, (loopcheck' _260232 env x t) = (exists y : N, (@IN N y (free_variables_term t)) /\ ((y = x) \/ (exists s : term, (@List.In (prod N term) (@pair N term y s) env) /\ (loopcheck' _260232 env x s))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0))))))))))))))))).
Proof. exact (eq_refl loopcheck). Qed.
Definition unify : (prod (list (prod N term)) (list (prod term term))) -> option (list (prod N term)) := @ε ((prod N (prod N (prod N (prod N N)))) -> (prod (list (prod N term)) (list (prod term term))) -> option (list (prod N term))) (fun unify' : (prod N (prod N (prod N (prod N N)))) -> (prod (list (prod N term)) (list (prod term term))) -> option (list (prod N term)) => forall _268410 : prod N (prod N (prod N (prod N N))), forall pr : prod (list (prod N term)) (list (prod term term)), (unify' _268410 pr) = (@COND (option (list (prod N term))) (~ (LOOPFREE (@fst (list (prod N term)) (list (prod term term)) pr))) (@None (list (prod N term))) (@COND (option (list (prod N term))) ((@snd (list (prod N term)) (list (prod term term)) pr) = (@nil (prod term term))) (@Some (list (prod N term)) (@fst (list (prod N term)) (list (prod term term)) pr)) (@tpcases (option (list (prod N term))) (fun f : N => fun fargs : list term => fun g : N => fun gargs : list term => @COND (option (list (prod N term))) ((f = g) /\ ((@lengthN term fargs) = (@lengthN term gargs))) (unify' _268410 (@pair (list (prod N term)) (list (prod term term)) (@fst (list (prod N term)) (list (prod term term)) pr) (@app (prod term term) (@zip term term fargs gargs) (@HOLLight_Real_With_N.mappings.tl (prod term term) (@snd (list (prod N term)) (list (prod term term)) pr))))) (@None (list (prod N term)))) (fun x : N => fun t : term => @COND (option (list (prod N term))) (@List.In N x (@List.map (prod N term) N (@fst N term) (@fst (list (prod N term)) (list (prod term term)) pr))) (unify' _268410 (@pair (list (prod N term)) (list (prod term term)) (@fst (list (prod N term)) (list (prod term term)) pr) (@cons (prod term term) (@pair term term (@assoc N term x (@fst (list (prod N term)) (list (prod term term)) pr)) t) (@HOLLight_Real_With_N.mappings.tl (prod term term) (@snd (list (prod N term)) (list (prod term term)) pr))))) (@COND (option (list (prod N term))) ((istriv (@fst (list (prod N term)) (list (prod term term)) pr) x t) = Exception) (@None (list (prod N term))) (@COND (option (list (prod N term))) ((istriv (@fst (list (prod N term)) (list (prod term term)) pr) x t) = TT) (unify' _268410 (@pair (list (prod N term)) (list (prod term term)) (@fst (list (prod N term)) (list (prod term term)) pr) (@HOLLight_Real_With_N.mappings.tl (prod term term) (@snd (list (prod N term)) (list (prod term term)) pr)))) (unify' _268410 (@pair (list (prod N term)) (list (prod term term)) (@cons (prod N term) (@pair N term x t) (@fst (list (prod N term)) (list (prod term term)) pr)) (@HOLLight_Real_With_N.mappings.tl (prod term term) (@snd (list (prod N term)) (list (prod term term)) pr))))))) (fun f : N => fun args : list term => fun x : N => unify' _268410 (@pair (list (prod N term)) (list (prod term term)) (@fst (list (prod N term)) (list (prod term term)) pr) (@cons (prod term term) (@pair term term (V x) (Fn f args)) (@HOLLight_Real_With_N.mappings.tl (prod term term) (@snd (list (prod N term)) (list (prod term term)) pr))))) (@HOLLight_Real_With_N.mappings.hd (prod term term) (@snd (list (prod N term)) (list (prod term term)) pr)))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 N0)))))))))))).
Lemma unify_def : unify = (@ε ((prod N (prod N (prod N (prod N N)))) -> (prod (list (prod N term)) (list (prod term term))) -> option (list (prod N term))) (fun unify' : (prod N (prod N (prod N (prod N N)))) -> (prod (list (prod N term)) (list (prod term term))) -> option (list (prod N term)) => forall _268410 : prod N (prod N (prod N (prod N N))), forall pr : prod (list (prod N term)) (list (prod term term)), (unify' _268410 pr) = (@COND (option (list (prod N term))) (~ (LOOPFREE (@fst (list (prod N term)) (list (prod term term)) pr))) (@None (list (prod N term))) (@COND (option (list (prod N term))) ((@snd (list (prod N term)) (list (prod term term)) pr) = (@nil (prod term term))) (@Some (list (prod N term)) (@fst (list (prod N term)) (list (prod term term)) pr)) (@tpcases (option (list (prod N term))) (fun f : N => fun fargs : list term => fun g : N => fun gargs : list term => @COND (option (list (prod N term))) ((f = g) /\ ((@lengthN term fargs) = (@lengthN term gargs))) (unify' _268410 (@pair (list (prod N term)) (list (prod term term)) (@fst (list (prod N term)) (list (prod term term)) pr) (@app (prod term term) (@zip term term fargs gargs) (@HOLLight_Real_With_N.mappings.tl (prod term term) (@snd (list (prod N term)) (list (prod term term)) pr))))) (@None (list (prod N term)))) (fun x : N => fun t : term => @COND (option (list (prod N term))) (@List.In N x (@List.map (prod N term) N (@fst N term) (@fst (list (prod N term)) (list (prod term term)) pr))) (unify' _268410 (@pair (list (prod N term)) (list (prod term term)) (@fst (list (prod N term)) (list (prod term term)) pr) (@cons (prod term term) (@pair term term (@assoc N term x (@fst (list (prod N term)) (list (prod term term)) pr)) t) (@HOLLight_Real_With_N.mappings.tl (prod term term) (@snd (list (prod N term)) (list (prod term term)) pr))))) (@COND (option (list (prod N term))) ((istriv (@fst (list (prod N term)) (list (prod term term)) pr) x t) = Exception) (@None (list (prod N term))) (@COND (option (list (prod N term))) ((istriv (@fst (list (prod N term)) (list (prod term term)) pr) x t) = TT) (unify' _268410 (@pair (list (prod N term)) (list (prod term term)) (@fst (list (prod N term)) (list (prod term term)) pr) (@HOLLight_Real_With_N.mappings.tl (prod term term) (@snd (list (prod N term)) (list (prod term term)) pr)))) (unify' _268410 (@pair (list (prod N term)) (list (prod term term)) (@cons (prod N term) (@pair N term x t) (@fst (list (prod N term)) (list (prod term term)) pr)) (@HOLLight_Real_With_N.mappings.tl (prod term term) (@snd (list (prod N term)) (list (prod term term)) pr))))))) (fun f : N => fun args : list term => fun x : N => unify' _268410 (@pair (list (prod N term)) (list (prod term term)) (@fst (list (prod N term)) (list (prod term term)) pr) (@cons (prod term term) (@pair term term (V x) (Fn f args)) (@HOLLight_Real_With_N.mappings.tl (prod term term) (@snd (list (prod N term)) (list (prod term term)) pr))))) (@HOLLight_Real_With_N.mappings.hd (prod term term) (@snd (list (prod N term)) (list (prod term term)) pr)))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 N0))))))))))))).
Proof. exact (eq_refl unify). Qed.
Definition unifies : (N -> term) -> (list (prod term term)) -> Prop := fun _268411 : N -> term => fun _268412 : list (prod term term) => @List.Forall (prod term term) (@ε ((prod term term) -> Prop) (fun f : (prod term term) -> Prop => forall s : term, forall t : term, @eq Prop (f (@pair term term s t)) ((termsubst _268411 s) = (termsubst _268411 t)))) _268412.
Lemma unifies_def : unifies = (fun _268411 : N -> term => fun _268412 : list (prod term term) => @List.Forall (prod term term) (@ε ((prod term term) -> Prop) (fun f : (prod term term) -> Prop => forall s : term, forall t : term, @eq Prop (f (@pair term term s t)) ((termsubst _268411 s) = (termsubst _268411 t)))) _268412).
Proof. exact (eq_refl unifies). Qed.
Definition THE {_211969 : Type'} : (option _211969) -> _211969 := @ε ((prod N (prod N N)) -> (option _211969) -> _211969) (fun THE' : (prod N (prod N N)) -> (option _211969) -> _211969 => forall _274433 : prod N (prod N N), forall x : _211969, (THE' _274433 (@Some _211969 x)) = x) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))))).
Lemma THE_def {_211969 : Type'} : (@THE _211969) = (@ε ((prod N (prod N N)) -> (option _211969) -> _211969) (fun THE' : (prod N (prod N N)) -> (option _211969) -> _211969 => forall _274433 : prod N (prod N N), forall x : _211969, (THE' _274433 (@Some _211969 x)) = x) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0))))))))))).
Proof. exact (eq_refl (@THE _211969)). Qed.
Definition unifier : (list (prod N term)) -> N -> term := fun _274434 : list (prod N term) => @Basics.apply (list (prod N term)) (N -> term) (fun sol : list (prod N term) => @Datatypes.id (N -> term) (@fold_right_with_perm_args (prod N term) (N -> term) (@valmod term N) sol V)) (SOLVE (@nil (prod N term)) _274434).
Lemma unifier_def : unifier = (fun _274434 : list (prod N term) => @Basics.apply (list (prod N term)) (N -> term) (fun sol : list (prod N term) => @Datatypes.id (N -> term) (@fold_right_with_perm_args (prod N term) (N -> term) (@valmod term N) sol V)) (SOLVE (@nil (prod N term)) _274434)).
Proof. exact (eq_refl unifier). Qed.
Definition Unifies : (N -> term) -> (form -> Prop) -> Prop := fun _275904 : N -> term => fun _275905 : form -> Prop => forall p : form, forall q : form, ((@IN form p _275905) /\ (@IN form q _275905)) -> (formsubst _275904 p) = (formsubst _275904 q).
Lemma Unifies_def : Unifies = (fun _275904 : N -> term => fun _275905 : form -> Prop => forall p : form, forall q : form, ((@IN form p _275905) /\ (@IN form q _275905)) -> (formsubst _275904 p) = (formsubst _275904 q)).
Proof. exact (eq_refl Unifies). Qed.
Definition mgu : (form -> Prop) -> N -> term := fun _276282 : form -> Prop => @ε (N -> term) (fun i : N -> term => (Unifies i _276282) /\ (forall j : N -> term, (Unifies j _276282) -> forall p : form, (qfree p) -> (formsubst j p) = (formsubst j (formsubst i p)))).
Lemma mgu_def : mgu = (fun _276282 : form -> Prop => @ε (N -> term) (fun i : N -> term => (Unifies i _276282) /\ (forall j : N -> term, (Unifies j _276282) -> forall p : form, (qfree p) -> (formsubst j p) = (formsubst j (formsubst i p))))).
Proof. exact (eq_refl mgu). Qed.
Definition ismgu : (form -> Prop) -> (N -> term) -> Prop := fun _276290 : form -> Prop => fun _276291 : N -> term => (Unifies _276291 _276290) /\ (forall j : N -> term, (Unifies j _276290) -> exists k : N -> term, (termsubst j) = (@Basics.compose term term term (termsubst k) (termsubst _276291))).
Lemma ismgu_def : ismgu = (fun _276290 : form -> Prop => fun _276291 : N -> term => (Unifies _276291 _276290) /\ (forall j : N -> term, (Unifies j _276290) -> exists k : N -> term, (termsubst j) = (@Basics.compose term term term (termsubst k) (termsubst _276291)))).
Proof. exact (eq_refl ismgu). Qed.
Definition renaming : (N -> term) -> Prop := fun _276319 : N -> term => exists j : N -> term, ((@Basics.compose term term term (termsubst j) (termsubst _276319)) = (@Datatypes.id term)) /\ ((@Basics.compose term term term (termsubst _276319) (termsubst j)) = (@Datatypes.id term)).
Lemma renaming_def : renaming = (fun _276319 : N -> term => exists j : N -> term, ((@Basics.compose term term term (termsubst j) (termsubst _276319)) = (@Datatypes.id term)) /\ ((@Basics.compose term term term (termsubst _276319) (termsubst j)) = (@Datatypes.id term))).
Proof. exact (eq_refl renaming). Qed.
Definition atom : form -> Prop := @ε ((prod N (prod N (prod N N))) -> form -> Prop) (fun atom' : (prod N (prod N (prod N N))) -> form -> Prop => forall _276403 : prod N (prod N (prod N N)), ((atom' _276403 FFalse) = False) /\ ((forall p : N, forall l : list term, (atom' _276403 (Atom p l)) = True) /\ ((forall q : form, forall r : form, (atom' _276403 (FImp q r)) = False) /\ (forall x : N, forall q : form, (atom' _276403 (FAll x q)) = False)))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0))))))))))).
Lemma atom_def : atom = (@ε ((prod N (prod N (prod N N))) -> form -> Prop) (fun atom' : (prod N (prod N (prod N N))) -> form -> Prop => forall _276403 : prod N (prod N (prod N N)), ((atom' _276403 FFalse) = False) /\ ((forall p : N, forall l : list term, (atom' _276403 (Atom p l)) = True) /\ ((forall q : form, forall r : form, (atom' _276403 (FImp q r)) = False) /\ (forall x : N, forall q : form, (atom' _276403 (FAll x q)) = False)))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))))))).
Proof. exact (eq_refl atom). Qed.
Definition literal : form -> Prop := fun _276404 : form => (atom _276404) \/ (exists q : form, (atom q) /\ (_276404 = (Not q))).
Lemma literal_def : literal = (fun _276404 : form => (atom _276404) \/ (exists q : form, (atom q) /\ (_276404 = (Not q)))).
Proof. exact (eq_refl literal). Qed.
Definition clause : (form -> Prop) -> Prop := fun _276409 : form -> Prop => (@FINITE form _276409) /\ (forall p : form, (@IN form p _276409) -> literal p).
Lemma clause_def : clause = (fun _276409 : form -> Prop => (@FINITE form _276409) /\ (forall p : form, (@IN form p _276409) -> literal p)).
Proof. exact (eq_refl clause). Qed.
Definition negative : form -> Prop := fun _276554 : form => exists q : form, _276554 = (Not q).
Lemma negative_def : negative = (fun _276554 : form => exists q : form, _276554 = (Not q)).
Proof. exact (eq_refl negative). Qed.
Definition positive : form -> Prop := fun _276559 : form => ~ (negative _276559).
Lemma positive_def : positive = (fun _276559 : form => ~ (negative _276559)).
Proof. exact (eq_refl positive). Qed.
Definition FNot : form -> form := fun _276564 : form => @COND form (negative _276564) (@ε form (fun q : form => (Not q) = _276564)) (Not _276564).
Lemma FNot_def : FNot = (fun _276564 : form => @COND form (negative _276564) (@ε form (fun q : form => (Not q) = _276564)) (Not _276564)).
Proof. exact (eq_refl FNot). Qed.
Definition resolve : form -> (form -> Prop) -> (form -> Prop) -> form -> Prop := fun _276622 : form => fun _276623 : form -> Prop => fun _276624 : form -> Prop => @Ensembles.Union form (@Ensembles.Subtract form _276623 _276622) (@Ensembles.Subtract form _276624 (FNot _276622)).
Lemma resolve_def : resolve = (fun _276622 : form => fun _276623 : form -> Prop => fun _276624 : form -> Prop => @Ensembles.Union form (@Ensembles.Subtract form _276623 _276622) (@Ensembles.Subtract form _276624 (FNot _276622))).
Proof. exact (eq_refl resolve). Qed.
Definition presproof : ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop := fun hyps' : (form -> Prop) -> Prop => fun a : form -> Prop => forall presproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, ((@IN (form -> Prop) a' hyps') \/ (exists p : form, exists cl1 : form -> Prop, exists cl2 : form -> Prop, (a' = (resolve p cl1 cl2)) /\ ((presproof' cl1) /\ ((presproof' cl2) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2)))))) -> presproof' a') -> presproof' a.
Lemma presproof_def : presproof = (fun hyps' : (form -> Prop) -> Prop => fun a : form -> Prop => forall presproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, ((@IN (form -> Prop) a' hyps') \/ (exists p : form, exists cl1 : form -> Prop, exists cl2 : form -> Prop, (a' = (resolve p cl1 cl2)) /\ ((presproof' cl1) /\ ((presproof' cl2) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2)))))) -> presproof' a') -> presproof' a).
Proof. exact (eq_refl presproof). Qed.
Definition interp : (form -> Prop) -> form := fun _276649 : form -> Prop => @fold_right_with_perm_args form form FOr (@list_of_set form _276649) FFalse.
Lemma interp_def : interp = (fun _276649 : form -> Prop => @fold_right_with_perm_args form form FOr (@list_of_set form _276649) FFalse).
Proof. exact (eq_refl interp). Qed.
Definition instance_of : (form -> Prop) -> (form -> Prop) -> Prop := fun _282937 : form -> Prop => fun _282938 : form -> Prop => exists i : N -> term, _282937 = (@IMAGE form form (formsubst i) _282938).
Lemma instance_of_def : instance_of = (fun _282937 : form -> Prop => fun _282938 : form -> Prop => exists i : N -> term, _282937 = (@IMAGE form form (formsubst i) _282938)).
Proof. exact (eq_refl instance_of). Qed.
Definition FVS : (form -> Prop) -> N -> Prop := fun _282949 : form -> Prop => @UNIONS N (@GSPEC (N -> Prop) (fun GEN_PVAR_527 : N -> Prop => exists p : form, @SETSPEC (N -> Prop) GEN_PVAR_527 (@IN form p _282949) (free_variables p))).
Lemma FVS_def : FVS = (fun _282949 : form -> Prop => @UNIONS N (@GSPEC (N -> Prop) (fun GEN_PVAR_527 : N -> Prop => exists p : form, @SETSPEC (N -> Prop) GEN_PVAR_527 (@IN form p _282949) (free_variables p)))).
Proof. exact (eq_refl FVS). Qed.
Definition rename : (form -> Prop) -> (N -> Prop) -> N -> term := @ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (form -> Prop) -> (N -> Prop) -> N -> term) (fun i : (prod N (prod N (prod N (prod N (prod N N))))) -> (form -> Prop) -> (N -> Prop) -> N -> term => forall _285948 : prod N (prod N (prod N (prod N (prod N N)))), forall cl : form -> Prop, forall s : N -> Prop, ((@FINITE N s) /\ (clause cl)) -> (renaming (i _285948 cl s)) /\ ((@Ensembles.Intersection N (FVS (@IMAGE form form (formsubst (i _285948 cl s)) cl)) s) = (@Ensembles.Empty_set N))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0))))))))))))).
Lemma rename_def : rename = (@ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (form -> Prop) -> (N -> Prop) -> N -> term) (fun i : (prod N (prod N (prod N (prod N (prod N N))))) -> (form -> Prop) -> (N -> Prop) -> N -> term => forall _285948 : prod N (prod N (prod N (prod N (prod N N)))), forall cl : form -> Prop, forall s : N -> Prop, ((@FINITE N s) /\ (clause cl)) -> (renaming (i _285948 cl s)) /\ ((@Ensembles.Intersection N (FVS (@IMAGE form form (formsubst (i _285948 cl s)) cl)) s) = (@Ensembles.Empty_set N))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))))))))).
Proof. exact (eq_refl rename). Qed.
Definition resproof : ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop := fun hyps' : (form -> Prop) -> Prop => fun a : form -> Prop => forall resproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, ((@IN (form -> Prop) a' hyps') \/ (exists cl1 : form -> Prop, exists cl2 : form -> Prop, exists cl2' : form -> Prop, exists ps1 : form -> Prop, exists ps2 : form -> Prop, exists i : N -> term, (a' = (@IMAGE form form (formsubst i) (@Ensembles.Union form (@Ensembles.Setminus form cl1 ps1) (@Ensembles.Setminus form cl2' ps2)))) /\ ((resproof' cl1) /\ ((resproof' cl2) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@Ensembles.Included form ps1 cl1) /\ ((@Ensembles.Included form ps2 cl2') /\ ((~ (ps1 = (@Ensembles.Empty_set form))) /\ ((~ (ps2 = (@Ensembles.Empty_set form))) /\ ((exists i' : N -> term, Unifies i' (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_533 : form => exists p : form, @SETSPEC form GEN_PVAR_533 (@IN form p ps2) (FNot p))))) /\ ((mgu (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_534 : form => exists p : form, @SETSPEC form GEN_PVAR_534 (@IN form p ps2) (FNot p))))) = i))))))))))) -> resproof' a') -> resproof' a.
Lemma resproof_def : resproof = (fun hyps' : (form -> Prop) -> Prop => fun a : form -> Prop => forall resproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, ((@IN (form -> Prop) a' hyps') \/ (exists cl1 : form -> Prop, exists cl2 : form -> Prop, exists cl2' : form -> Prop, exists ps1 : form -> Prop, exists ps2 : form -> Prop, exists i : N -> term, (a' = (@IMAGE form form (formsubst i) (@Ensembles.Union form (@Ensembles.Setminus form cl1 ps1) (@Ensembles.Setminus form cl2' ps2)))) /\ ((resproof' cl1) /\ ((resproof' cl2) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@Ensembles.Included form ps1 cl1) /\ ((@Ensembles.Included form ps2 cl2') /\ ((~ (ps1 = (@Ensembles.Empty_set form))) /\ ((~ (ps2 = (@Ensembles.Empty_set form))) /\ ((exists i' : N -> term, Unifies i' (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_533 : form => exists p : form, @SETSPEC form GEN_PVAR_533 (@IN form p ps2) (FNot p))))) /\ ((mgu (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_534 : form => exists p : form, @SETSPEC form GEN_PVAR_534 (@IN form p ps2) (FNot p))))) = i))))))))))) -> resproof' a') -> resproof' a).
Proof. exact (eq_refl resproof). Qed.
Definition isaresolvent : (form -> Prop) -> (prod (form -> Prop) (form -> Prop)) -> Prop := fun _289554 : form -> Prop => fun _289555 : prod (form -> Prop) (form -> Prop) => @Basics.apply (form -> Prop) Prop (fun cl2' : form -> Prop => @Datatypes.id Prop (exists ps1 : form -> Prop, exists ps2 : form -> Prop, (@Ensembles.Included form ps1 (@fst (form -> Prop) (form -> Prop) _289555)) /\ ((@Ensembles.Included form ps2 cl2') /\ ((~ (ps1 = (@Ensembles.Empty_set form))) /\ ((~ (ps2 = (@Ensembles.Empty_set form))) /\ ((exists i : N -> term, Unifies i (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_540 : form => exists p : form, @SETSPEC form GEN_PVAR_540 (@IN form p ps2) (FNot p))))) /\ (@Basics.apply (N -> term) Prop (fun i : N -> term => @Datatypes.id Prop (_289554 = (@IMAGE form form (formsubst i) (@Ensembles.Union form (@Ensembles.Setminus form (@fst (form -> Prop) (form -> Prop) _289555) ps1) (@Ensembles.Setminus form cl2' ps2))))) (mgu (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_541 : form => exists p : form, @SETSPEC form GEN_PVAR_541 (@IN form p ps2) (FNot p)))))))))))) (@IMAGE form form (formsubst (rename (@snd (form -> Prop) (form -> Prop) _289555) (FVS (@fst (form -> Prop) (form -> Prop) _289555)))) (@snd (form -> Prop) (form -> Prop) _289555)).
Lemma isaresolvent_def : isaresolvent = (fun _289554 : form -> Prop => fun _289555 : prod (form -> Prop) (form -> Prop) => @Basics.apply (form -> Prop) Prop (fun cl2' : form -> Prop => @Datatypes.id Prop (exists ps1 : form -> Prop, exists ps2 : form -> Prop, (@Ensembles.Included form ps1 (@fst (form -> Prop) (form -> Prop) _289555)) /\ ((@Ensembles.Included form ps2 cl2') /\ ((~ (ps1 = (@Ensembles.Empty_set form))) /\ ((~ (ps2 = (@Ensembles.Empty_set form))) /\ ((exists i : N -> term, Unifies i (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_540 : form => exists p : form, @SETSPEC form GEN_PVAR_540 (@IN form p ps2) (FNot p))))) /\ (@Basics.apply (N -> term) Prop (fun i : N -> term => @Datatypes.id Prop (_289554 = (@IMAGE form form (formsubst i) (@Ensembles.Union form (@Ensembles.Setminus form (@fst (form -> Prop) (form -> Prop) _289555) ps1) (@Ensembles.Setminus form cl2' ps2))))) (mgu (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_541 : form => exists p : form, @SETSPEC form GEN_PVAR_541 (@IN form p ps2) (FNot p)))))))))))) (@IMAGE form form (formsubst (rename (@snd (form -> Prop) (form -> Prop) _289555) (FVS (@fst (form -> Prop) (form -> Prop) _289555)))) (@snd (form -> Prop) (form -> Prop) _289555))).
Proof. exact (eq_refl isaresolvent). Qed.
Definition FIRSTN {_216234 : Type'} : N -> (list _216234) -> list _216234 := @ε ((prod N (prod N (prod N (prod N (prod N N))))) -> N -> (list _216234) -> list _216234) (fun FIRSTN' : (prod N (prod N (prod N (prod N (prod N N))))) -> N -> (list _216234) -> list _216234 => forall _289585 : prod N (prod N (prod N (prod N (prod N N)))), (forall l : list _216234, (FIRSTN' _289585 (NUMERAL N0) l) = (@nil _216234)) /\ (forall n : N, forall l : list _216234, (FIRSTN' _289585 (N.succ n) l) = (@COND (list _216234) (l = (@nil _216234)) (@nil _216234) (@cons _216234 (@HOLLight_Real_With_N.mappings.hd _216234 l) (FIRSTN' _289585 n (@HOLLight_Real_With_N.mappings.tl _216234 l)))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0))))))))))))).
Lemma FIRSTN_def {_216234 : Type'} : (@FIRSTN _216234) = (@ε ((prod N (prod N (prod N (prod N (prod N N))))) -> N -> (list _216234) -> list _216234) (fun FIRSTN' : (prod N (prod N (prod N (prod N (prod N N))))) -> N -> (list _216234) -> list _216234 => forall _289585 : prod N (prod N (prod N (prod N (prod N N)))), (forall l : list _216234, (FIRSTN' _289585 (NUMERAL N0) l) = (@nil _216234)) /\ (forall n : N, forall l : list _216234, (FIRSTN' _289585 (N.succ n) l) = (@COND (list _216234) (l = (@nil _216234)) (@nil _216234) (@cons _216234 (@HOLLight_Real_With_N.mappings.hd _216234 l) (FIRSTN' _289585 n (@HOLLight_Real_With_N.mappings.tl _216234 l)))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))))))))).
Proof. exact (eq_refl (@FIRSTN _216234)). Qed.
Definition tautologous : (form -> Prop) -> Prop := fun _290199 : form -> Prop => exists p : form, (@IN form p _290199) /\ (@IN form (FNot p) _290199).
Lemma tautologous_def : tautologous = (fun _290199 : form -> Prop => exists p : form, (@IN form p _290199) /\ (@IN form (FNot p) _290199)).
Proof. exact (eq_refl tautologous). Qed.
Definition subsumes : (form -> Prop) -> (form -> Prop) -> Prop := fun _290204 : form -> Prop => fun _290205 : form -> Prop => exists i : N -> term, @Ensembles.Included form (@IMAGE form form (formsubst i) _290204) _290205.
Lemma subsumes_def : subsumes = (fun _290204 : form -> Prop => fun _290205 : form -> Prop => exists i : N -> term, @Ensembles.Included form (@IMAGE form form (formsubst i) _290204) _290205).
Proof. exact (eq_refl subsumes). Qed.
Definition SUBSUMES : ((form -> Prop) -> Prop) -> ((form -> Prop) -> Prop) -> Prop := fun _290276 : (form -> Prop) -> Prop => fun _290277 : (form -> Prop) -> Prop => forall cl' : form -> Prop, (@IN (form -> Prop) cl' _290277) -> exists cl : form -> Prop, (@IN (form -> Prop) cl _290276) /\ (subsumes cl cl').
Lemma SUBSUMES_def : SUBSUMES = (fun _290276 : (form -> Prop) -> Prop => fun _290277 : (form -> Prop) -> Prop => forall cl' : form -> Prop, (@IN (form -> Prop) cl' _290277) -> exists cl : form -> Prop, (@IN (form -> Prop) cl _290276) /\ (subsumes cl cl')).
Proof. exact (eq_refl SUBSUMES). Qed.
Definition allresolvents : ((form -> Prop) -> Prop) -> ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop := fun _290388 : (form -> Prop) -> Prop => fun _290389 : (form -> Prop) -> Prop => @GSPEC (form -> Prop) (fun GEN_PVAR_542 : form -> Prop => exists c : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_542 (exists c1 : form -> Prop, exists c2 : form -> Prop, (@IN (form -> Prop) c1 _290388) /\ ((@IN (form -> Prop) c2 _290389) /\ (isaresolvent c (@pair (form -> Prop) (form -> Prop) c1 c2)))) c).
Lemma allresolvents_def : allresolvents = (fun _290388 : (form -> Prop) -> Prop => fun _290389 : (form -> Prop) -> Prop => @GSPEC (form -> Prop) (fun GEN_PVAR_542 : form -> Prop => exists c : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_542 (exists c1 : form -> Prop, exists c2 : form -> Prop, (@IN (form -> Prop) c1 _290388) /\ ((@IN (form -> Prop) c2 _290389) /\ (isaresolvent c (@pair (form -> Prop) (form -> Prop) c1 c2)))) c)).
Proof. exact (eq_refl allresolvents). Qed.
Definition allntresolvents : ((form -> Prop) -> Prop) -> ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop := fun _290400 : (form -> Prop) -> Prop => fun _290401 : (form -> Prop) -> Prop => @GSPEC (form -> Prop) (fun GEN_PVAR_543 : form -> Prop => exists r : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_543 ((@IN (form -> Prop) r (allresolvents _290400 _290401)) /\ (~ (tautologous r))) r).
Lemma allntresolvents_def : allntresolvents = (fun _290400 : (form -> Prop) -> Prop => fun _290401 : (form -> Prop) -> Prop => @GSPEC (form -> Prop) (fun GEN_PVAR_543 : form -> Prop => exists r : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_543 ((@IN (form -> Prop) r (allresolvents _290400 _290401)) /\ (~ (tautologous r))) r)).
Proof. exact (eq_refl allntresolvents). Qed.
Definition resolvents : (form -> Prop) -> (list (form -> Prop)) -> list (form -> Prop) := fun _315994 : form -> Prop => fun _315995 : list (form -> Prop) => @list_of_set (form -> Prop) (allresolvents (@INSERT (form -> Prop) _315994 (@Ensembles.Empty_set (form -> Prop))) (@set_of_list (form -> Prop) _315995)).
Lemma resolvents_def : resolvents = (fun _315994 : form -> Prop => fun _315995 : list (form -> Prop) => @list_of_set (form -> Prop) (allresolvents (@INSERT (form -> Prop) _315994 (@Ensembles.Empty_set (form -> Prop))) (@set_of_list (form -> Prop) _315995))).
Proof. exact (eq_refl resolvents). Qed.
Definition replace : (form -> Prop) -> (list (form -> Prop)) -> list (form -> Prop) := @ε ((prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (form -> Prop) -> (list (form -> Prop)) -> list (form -> Prop)) (fun replace' : (prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (form -> Prop) -> (list (form -> Prop)) -> list (form -> Prop) => forall _316246 : prod N (prod N (prod N (prod N (prod N (prod N N))))), (forall cl : form -> Prop, (replace' _316246 cl (@nil (form -> Prop))) = (@cons (form -> Prop) cl (@nil (form -> Prop)))) /\ (forall c : form -> Prop, forall cl : form -> Prop, forall cls : list (form -> Prop), (replace' _316246 cl (@cons (form -> Prop) c cls)) = (@COND (list (form -> Prop)) (subsumes cl c) (@cons (form -> Prop) cl cls) (@cons (form -> Prop) c (replace' _316246 cl cls))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))))))))).
Lemma replace_def : replace = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (form -> Prop) -> (list (form -> Prop)) -> list (form -> Prop)) (fun replace' : (prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (form -> Prop) -> (list (form -> Prop)) -> list (form -> Prop) => forall _316246 : prod N (prod N (prod N (prod N (prod N (prod N N))))), (forall cl : form -> Prop, (replace' _316246 cl (@nil (form -> Prop))) = (@cons (form -> Prop) cl (@nil (form -> Prop)))) /\ (forall c : form -> Prop, forall cl : form -> Prop, forall cls : list (form -> Prop), (replace' _316246 cl (@cons (form -> Prop) c cls)) = (@COND (list (form -> Prop)) (subsumes cl c) (@cons (form -> Prop) cl cls) (@cons (form -> Prop) c (replace' _316246 cl cls))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0))))))))))))))).
Proof. exact (eq_refl replace). Qed.
Definition incorporate : (form -> Prop) -> (form -> Prop) -> (list (form -> Prop)) -> list (form -> Prop) := fun _316633 : form -> Prop => fun _316634 : form -> Prop => fun _316635 : list (form -> Prop) => @COND (list (form -> Prop)) ((tautologous _316634) \/ (@List.Exists (form -> Prop) (fun c : form -> Prop => subsumes c _316634) (@cons (form -> Prop) _316633 _316635))) _316635 (replace _316634 _316635).
Lemma incorporate_def : incorporate = (fun _316633 : form -> Prop => fun _316634 : form -> Prop => fun _316635 : list (form -> Prop) => @COND (list (form -> Prop)) ((tautologous _316634) \/ (@List.Exists (form -> Prop) (fun c : form -> Prop => subsumes c _316634) (@cons (form -> Prop) _316633 _316635))) _316635 (replace _316634 _316635)).
Proof. exact (eq_refl incorporate). Qed.
Definition insert {_218810 : Type'} : _218810 -> (list _218810) -> list _218810 := fun _316826 : _218810 => fun _316827 : list _218810 => @COND (list _218810) (@List.In _218810 _316826 _316827) _316827 (@cons _218810 _316826 _316827).
Lemma insert_def {_218810 : Type'} : (@insert _218810) = (fun _316826 : _218810 => fun _316827 : list _218810 => @COND (list _218810) (@List.In _218810 _316826 _316827) _316827 (@cons _218810 _316826 _316827)).
Proof. exact (eq_refl (@insert _218810)). Qed.
Definition step : (prod (list (form -> Prop)) (list (form -> Prop))) -> prod (list (form -> Prop)) (list (form -> Prop)) := fun _316838 : prod (list (form -> Prop)) (list (form -> Prop)) => @COND (prod (list (form -> Prop)) (list (form -> Prop))) ((@snd (list (form -> Prop)) (list (form -> Prop)) _316838) = (@nil (form -> Prop))) (@pair (list (form -> Prop)) (list (form -> Prop)) (@fst (list (form -> Prop)) (list (form -> Prop)) _316838) (@snd (list (form -> Prop)) (list (form -> Prop)) _316838)) (@Basics.apply (list (form -> Prop)) (prod (list (form -> Prop)) (list (form -> Prop))) (fun new : list (form -> Prop) => @Datatypes.id (prod (list (form -> Prop)) (list (form -> Prop))) (@pair (list (form -> Prop)) (list (form -> Prop)) (@insert (form -> Prop) (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _316838)) (@fst (list (form -> Prop)) (list (form -> Prop)) _316838)) (@fold_right_with_perm_args (form -> Prop) (list (form -> Prop)) (incorporate (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _316838))) new (@HOLLight_Real_With_N.mappings.tl (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _316838))))) (resolvents (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _316838)) (@cons (form -> Prop) (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _316838)) (@fst (list (form -> Prop)) (list (form -> Prop)) _316838)))).
Lemma step_def : step = (fun _316838 : prod (list (form -> Prop)) (list (form -> Prop)) => @COND (prod (list (form -> Prop)) (list (form -> Prop))) ((@snd (list (form -> Prop)) (list (form -> Prop)) _316838) = (@nil (form -> Prop))) (@pair (list (form -> Prop)) (list (form -> Prop)) (@fst (list (form -> Prop)) (list (form -> Prop)) _316838) (@snd (list (form -> Prop)) (list (form -> Prop)) _316838)) (@Basics.apply (list (form -> Prop)) (prod (list (form -> Prop)) (list (form -> Prop))) (fun new : list (form -> Prop) => @Datatypes.id (prod (list (form -> Prop)) (list (form -> Prop))) (@pair (list (form -> Prop)) (list (form -> Prop)) (@insert (form -> Prop) (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _316838)) (@fst (list (form -> Prop)) (list (form -> Prop)) _316838)) (@fold_right_with_perm_args (form -> Prop) (list (form -> Prop)) (incorporate (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _316838))) new (@HOLLight_Real_With_N.mappings.tl (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _316838))))) (resolvents (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _316838)) (@cons (form -> Prop) (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _316838)) (@fst (list (form -> Prop)) (list (form -> Prop)) _316838))))).
Proof. exact (eq_refl step). Qed.
Definition given : N -> (prod (list (form -> Prop)) (list (form -> Prop))) -> prod (list (form -> Prop)) (list (form -> Prop)) := @ε ((prod N (prod N (prod N (prod N N)))) -> N -> (prod (list (form -> Prop)) (list (form -> Prop))) -> prod (list (form -> Prop)) (list (form -> Prop))) (fun given' : (prod N (prod N (prod N (prod N N)))) -> N -> (prod (list (form -> Prop)) (list (form -> Prop))) -> prod (list (form -> Prop)) (list (form -> Prop)) => forall _316850 : prod N (prod N (prod N (prod N N))), (forall p : prod (list (form -> Prop)) (list (form -> Prop)), (given' _316850 (NUMERAL N0) p) = p) /\ (forall n : N, forall p : prod (list (form -> Prop)) (list (form -> Prop)), (given' _316850 (N.succ n) p) = (step (given' _316850 n p)))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))))))).
Lemma given_def : given = (@ε ((prod N (prod N (prod N (prod N N)))) -> N -> (prod (list (form -> Prop)) (list (form -> Prop))) -> prod (list (form -> Prop)) (list (form -> Prop))) (fun given' : (prod N (prod N (prod N (prod N N)))) -> N -> (prod (list (form -> Prop)) (list (form -> Prop))) -> prod (list (form -> Prop)) (list (form -> Prop)) => forall _316850 : prod N (prod N (prod N (prod N N))), (forall p : prod (list (form -> Prop)) (list (form -> Prop)), (given' _316850 (NUMERAL N0) p) = p) /\ (forall n : N, forall p : prod (list (form -> Prop)) (list (form -> Prop)), (given' _316850 (N.succ n) p) = (step (given' _316850 n p)))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0))))))))))))).
Proof. exact (eq_refl given). Qed.
Definition Used : (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop := fun _316851 : prod (list (form -> Prop)) (list (form -> Prop)) => fun _316852 : N => @set_of_list (form -> Prop) (@fst (list (form -> Prop)) (list (form -> Prop)) (given _316852 _316851)).
Lemma Used_def : Used = (fun _316851 : prod (list (form -> Prop)) (list (form -> Prop)) => fun _316852 : N => @set_of_list (form -> Prop) (@fst (list (form -> Prop)) (list (form -> Prop)) (given _316852 _316851))).
Proof. exact (eq_refl Used). Qed.
Definition Unused : (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop := fun _316863 : prod (list (form -> Prop)) (list (form -> Prop)) => fun _316864 : N => @set_of_list (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given _316864 _316863)).
Lemma Unused_def : Unused = (fun _316863 : prod (list (form -> Prop)) (list (form -> Prop)) => fun _316864 : N => @set_of_list (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given _316864 _316863))).
Proof. exact (eq_refl Unused). Qed.
Definition Sub : (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop := @ε ((prod N (prod N N)) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop) (fun Sub' : (prod N (prod N N)) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop => forall _316881 : prod N (prod N N), (forall init : prod (list (form -> Prop)) (list (form -> Prop)), (Sub' _316881 init (NUMERAL N0)) = (@Ensembles.Empty_set (form -> Prop))) /\ (forall init : prod (list (form -> Prop)) (list (form -> Prop)), forall n : N, (Sub' _316881 init (N.succ n)) = (@COND ((form -> Prop) -> Prop) ((@snd (list (form -> Prop)) (list (form -> Prop)) (given n init)) = (@nil (form -> Prop))) (Sub' _316881 init n) (@INSERT (form -> Prop) (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given n init))) (Sub' _316881 init n))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))))).
Lemma Sub_def : Sub = (@ε ((prod N (prod N N)) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop) (fun Sub' : (prod N (prod N N)) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop => forall _316881 : prod N (prod N N), (forall init : prod (list (form -> Prop)) (list (form -> Prop)), (Sub' _316881 init (NUMERAL N0)) = (@Ensembles.Empty_set (form -> Prop))) /\ (forall init : prod (list (form -> Prop)) (list (form -> Prop)), forall n : N, (Sub' _316881 init (N.succ n)) = (@COND ((form -> Prop) -> Prop) ((@snd (list (form -> Prop)) (list (form -> Prop)) (given n init)) = (@nil (form -> Prop))) (Sub' _316881 init n) (@INSERT (form -> Prop) (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given n init))) (Sub' _316881 init n))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0))))))))))).
Proof. exact (eq_refl Sub). Qed.
Definition break : (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> N := @ε ((prod N (prod N (prod N (prod N N)))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> N) (fun break' : (prod N (prod N (prod N (prod N N)))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> N => forall _328646 : prod N (prod N (prod N (prod N N))), (forall init : prod (list (form -> Prop)) (list (form -> Prop)), (break' _328646 init (NUMERAL N0)) = (@lengthN (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given (NUMERAL N0) init)))) /\ (forall n : N, forall init : prod (list (form -> Prop)) (list (form -> Prop)), (break' _328646 init (N.succ n)) = (N.add (break' _328646 init n) (@lengthN (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given (break' _328646 init n) init)))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))))))).
Lemma break_def : break = (@ε ((prod N (prod N (prod N (prod N N)))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> N) (fun break' : (prod N (prod N (prod N (prod N N)))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> N => forall _328646 : prod N (prod N (prod N (prod N N))), (forall init : prod (list (form -> Prop)) (list (form -> Prop)), (break' _328646 init (NUMERAL N0)) = (@lengthN (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given (NUMERAL N0) init)))) /\ (forall n : N, forall init : prod (list (form -> Prop)) (list (form -> Prop)), (break' _328646 init (N.succ n)) = (N.add (break' _328646 init n) (@lengthN (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given (break' _328646 init n) init)))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0))))))))))))).
Proof. exact (eq_refl break). Qed.
Definition level : (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop := fun _328647 : prod (list (form -> Prop)) (list (form -> Prop)) => fun _328648 : N => Sub _328647 (break _328647 _328648).
Lemma level_def : level = (fun _328647 : prod (list (form -> Prop)) (list (form -> Prop)) => fun _328648 : N => Sub _328647 (break _328647 _328648)).
Proof. exact (eq_refl level). Qed.
Definition ppresproof : ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop := fun a0 : (form -> Prop) -> Prop => fun a1 : form -> Prop => forall ppresproof' : ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop, (forall a0' : (form -> Prop) -> Prop, forall a1' : form -> Prop, (((a0' = (@INSERT (form -> Prop) a1' (@Ensembles.Empty_set (form -> Prop)))) /\ (clause a1')) \/ (exists p : form, exists asm1 : (form -> Prop) -> Prop, exists asm2 : (form -> Prop) -> Prop, exists c1 : form -> Prop, exists c2 : form -> Prop, (a0' = (@Ensembles.Union (form -> Prop) asm1 asm2)) /\ ((a1' = (resolve p c1 c2)) /\ ((ppresproof' asm1 c1) /\ ((ppresproof' asm2 c2) /\ ((@IN form p c1) /\ (@IN form (FNot p) c2))))))) -> ppresproof' a0' a1') -> ppresproof' a0 a1.
Lemma ppresproof_def : ppresproof = (fun a0 : (form -> Prop) -> Prop => fun a1 : form -> Prop => forall ppresproof' : ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop, (forall a0' : (form -> Prop) -> Prop, forall a1' : form -> Prop, (((a0' = (@INSERT (form -> Prop) a1' (@Ensembles.Empty_set (form -> Prop)))) /\ (clause a1')) \/ (exists p : form, exists asm1 : (form -> Prop) -> Prop, exists asm2 : (form -> Prop) -> Prop, exists c1 : form -> Prop, exists c2 : form -> Prop, (a0' = (@Ensembles.Union (form -> Prop) asm1 asm2)) /\ ((a1' = (resolve p c1 c2)) /\ ((ppresproof' asm1 c1) /\ ((ppresproof' asm2 c2) /\ ((@IN form p c1) /\ (@IN form (FNot p) c2))))))) -> ppresproof' a0' a1') -> ppresproof' a0 a1).
Proof. exact (eq_refl ppresproof). Qed.
Definition lpresproof : ((form -> Prop) -> Prop) -> (list (form -> Prop)) -> Prop := fun hyps' : (form -> Prop) -> Prop => fun a : list (form -> Prop) => forall lpresproof' : (list (form -> Prop)) -> Prop, (forall a' : list (form -> Prop), ((exists cl : form -> Prop, (a' = (@cons (form -> Prop) cl (@nil (form -> Prop)))) /\ (@IN (form -> Prop) cl hyps')) \/ (exists c1 : form -> Prop, exists c2 : form -> Prop, exists lis : list (form -> Prop), exists p : form, (a' = (@cons (form -> Prop) (resolve p c1 c2) (@cons (form -> Prop) c1 lis))) /\ ((lpresproof' (@cons (form -> Prop) c1 lis)) /\ (((@IN (form -> Prop) c2 hyps') \/ (@List.In (form -> Prop) c2 lis)) /\ ((@IN form p c1) /\ (@IN form (FNot p) c2)))))) -> lpresproof' a') -> lpresproof' a.
Lemma lpresproof_def : lpresproof = (fun hyps' : (form -> Prop) -> Prop => fun a : list (form -> Prop) => forall lpresproof' : (list (form -> Prop)) -> Prop, (forall a' : list (form -> Prop), ((exists cl : form -> Prop, (a' = (@cons (form -> Prop) cl (@nil (form -> Prop)))) /\ (@IN (form -> Prop) cl hyps')) \/ (exists c1 : form -> Prop, exists c2 : form -> Prop, exists lis : list (form -> Prop), exists p : form, (a' = (@cons (form -> Prop) (resolve p c1 c2) (@cons (form -> Prop) c1 lis))) /\ ((lpresproof' (@cons (form -> Prop) c1 lis)) /\ (((@IN (form -> Prop) c2 hyps') \/ (@List.In (form -> Prop) c2 lis)) /\ ((@IN form p c1) /\ (@IN form (FNot p) c2)))))) -> lpresproof' a') -> lpresproof' a).
Proof. exact (eq_refl lpresproof). Qed.
Definition suffix {_224872 : Type'} : (list _224872) -> (list _224872) -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (list _224872) -> (list _224872) -> Prop) (fun suffix' : (prod N (prod N (prod N (prod N (prod N N))))) -> (list _224872) -> (list _224872) -> Prop => forall _374747 : prod N (prod N (prod N (prod N (prod N N)))), (forall lis : list _224872, (suffix' _374747 lis (@nil _224872)) = (lis = (@nil _224872))) /\ (forall s : _224872, forall lis : list _224872, forall cs : list _224872, (suffix' _374747 lis (@cons _224872 s cs)) = ((lis = (@cons _224872 s cs)) \/ (suffix' _374747 lis cs)))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 N0))))))))))))).
Lemma suffix_def {_224872 : Type'} : (@suffix _224872) = (@ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (list _224872) -> (list _224872) -> Prop) (fun suffix' : (prod N (prod N (prod N (prod N (prod N N))))) -> (list _224872) -> (list _224872) -> Prop => forall _374747 : prod N (prod N (prod N (prod N (prod N N)))), (forall lis : list _224872, (suffix' _374747 lis (@nil _224872)) = (lis = (@nil _224872))) /\ (forall s : _224872, forall lis : list _224872, forall cs : list _224872, (suffix' _374747 lis (@cons _224872 s cs)) = ((lis = (@cons _224872 s cs)) \/ (suffix' _374747 lis cs)))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 N0)))))))))))))).
Proof. exact (eq_refl (@suffix _224872)). Qed.
Definition lresproof : ((form -> Prop) -> Prop) -> (list (form -> Prop)) -> Prop := fun hyps' : (form -> Prop) -> Prop => fun a : list (form -> Prop) => forall lresproof' : (list (form -> Prop)) -> Prop, (forall a' : list (form -> Prop), ((exists cl : form -> Prop, (a' = (@cons (form -> Prop) cl (@nil (form -> Prop)))) /\ (@IN (form -> Prop) cl hyps')) \/ (exists c1 : form -> Prop, exists c2 : form -> Prop, exists lis : list (form -> Prop), exists cl : form -> Prop, (a' = (@cons (form -> Prop) cl (@cons (form -> Prop) c1 lis))) /\ ((lresproof' (@cons (form -> Prop) c1 lis)) /\ (((@IN (form -> Prop) c2 hyps') \/ (@List.In (form -> Prop) c2 lis)) /\ (isaresolvent cl (@pair (form -> Prop) (form -> Prop) c1 c2)))))) -> lresproof' a') -> lresproof' a.
Lemma lresproof_def : lresproof = (fun hyps' : (form -> Prop) -> Prop => fun a : list (form -> Prop) => forall lresproof' : (list (form -> Prop)) -> Prop, (forall a' : list (form -> Prop), ((exists cl : form -> Prop, (a' = (@cons (form -> Prop) cl (@nil (form -> Prop)))) /\ (@IN (form -> Prop) cl hyps')) \/ (exists c1 : form -> Prop, exists c2 : form -> Prop, exists lis : list (form -> Prop), exists cl : form -> Prop, (a' = (@cons (form -> Prop) cl (@cons (form -> Prop) c1 lis))) /\ ((lresproof' (@cons (form -> Prop) c1 lis)) /\ (((@IN (form -> Prop) c2 hyps') \/ (@List.In (form -> Prop) c2 lis)) /\ (isaresolvent cl (@pair (form -> Prop) (form -> Prop) c1 c2)))))) -> lresproof' a') -> lresproof' a).
Proof. exact (eq_refl lresproof). Qed.
Definition npresproof : ((form -> Prop) -> Prop) -> (form -> Prop) -> N -> Prop := fun hyps' : (form -> Prop) -> Prop => fun a0 : form -> Prop => fun a1 : N => forall npresproof' : (form -> Prop) -> N -> Prop, (forall a0' : form -> Prop, forall a1' : N, (((a1' = (NUMERAL (BIT1 N0))) /\ (@IN (form -> Prop) a0' hyps')) \/ (exists p : form, exists n1 : N, exists n2 : N, exists cl1 : form -> Prop, exists cl2 : form -> Prop, (a0' = (resolve p cl1 cl2)) /\ ((a1' = (N.add n1 (N.add n2 (NUMERAL (BIT1 N0))))) /\ ((npresproof' cl1 n1) /\ ((npresproof' cl2 n2) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2))))))) -> npresproof' a0' a1') -> npresproof' a0 a1.
Lemma npresproof_def : npresproof = (fun hyps' : (form -> Prop) -> Prop => fun a0 : form -> Prop => fun a1 : N => forall npresproof' : (form -> Prop) -> N -> Prop, (forall a0' : form -> Prop, forall a1' : N, (((a1' = (NUMERAL (BIT1 N0))) /\ (@IN (form -> Prop) a0' hyps')) \/ (exists p : form, exists n1 : N, exists n2 : N, exists cl1 : form -> Prop, exists cl2 : form -> Prop, (a0' = (resolve p cl1 cl2)) /\ ((a1' = (N.add n1 (N.add n2 (NUMERAL (BIT1 N0))))) /\ ((npresproof' cl1 n1) /\ ((npresproof' cl2 n2) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2))))))) -> npresproof' a0' a1') -> npresproof' a0 a1).
Proof. exact (eq_refl npresproof). Qed.
Definition psresproof : ((form -> Prop) -> Prop) -> ((form -> Prop) -> Prop) -> Prop -> (form -> Prop) -> Prop := fun hyps' : (form -> Prop) -> Prop => fun sos : (form -> Prop) -> Prop => fun a0 : Prop => fun a1 : form -> Prop => forall psresproof' : Prop -> (form -> Prop) -> Prop, (forall a0' : Prop, forall a1' : form -> Prop, (((a0' = (@IN (form -> Prop) a1' sos)) /\ ((@IN (form -> Prop) a1' hyps') /\ (~ (tautologous a1')))) \/ (exists c1 : form -> Prop, exists c2 : form -> Prop, exists s1 : Prop, exists s2 : Prop, exists p : form, (a0' = True) /\ ((a1' = (resolve p c1 c2)) /\ ((psresproof' s1 c1) /\ ((psresproof' s2 c2) /\ ((@IN form p c1) /\ ((@IN form (FNot p) c2) /\ ((s1 \/ s2) /\ (~ (tautologous (resolve p c1 c2))))))))))) -> psresproof' a0' a1') -> psresproof' a0 a1.
Lemma psresproof_def : psresproof = (fun hyps' : (form -> Prop) -> Prop => fun sos : (form -> Prop) -> Prop => fun a0 : Prop => fun a1 : form -> Prop => forall psresproof' : Prop -> (form -> Prop) -> Prop, (forall a0' : Prop, forall a1' : form -> Prop, (((a0' = (@IN (form -> Prop) a1' sos)) /\ ((@IN (form -> Prop) a1' hyps') /\ (~ (tautologous a1')))) \/ (exists c1 : form -> Prop, exists c2 : form -> Prop, exists s1 : Prop, exists s2 : Prop, exists p : form, (a0' = True) /\ ((a1' = (resolve p c1 c2)) /\ ((psresproof' s1 c1) /\ ((psresproof' s2 c2) /\ ((@IN form p c1) /\ ((@IN form (FNot p) c2) /\ ((s1 \/ s2) /\ (~ (tautologous (resolve p c1 c2))))))))))) -> psresproof' a0' a1') -> psresproof' a0 a1).
Proof. exact (eq_refl psresproof). Qed.
Definition spresproof : ((form -> Prop) -> Prop) -> ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop := fun hyps' : (form -> Prop) -> Prop => fun sos : (form -> Prop) -> Prop => fun a : form -> Prop => forall spresproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, (((@IN (form -> Prop) a' hyps') /\ ((@IN (form -> Prop) a' sos) /\ (~ (tautologous a')))) \/ (exists c1 : form -> Prop, exists c2 : form -> Prop, exists p : form, (a' = (resolve p c1 c2)) /\ ((spresproof' c1) /\ (((spresproof' c2) \/ (@IN (form -> Prop) c2 hyps')) /\ ((@IN form p c1) /\ ((@IN form (FNot p) c2) /\ (~ (tautologous (resolve p c1 c2))))))))) -> spresproof' a') -> spresproof' a.
Lemma spresproof_def : spresproof = (fun hyps' : (form -> Prop) -> Prop => fun sos : (form -> Prop) -> Prop => fun a : form -> Prop => forall spresproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, (((@IN (form -> Prop) a' hyps') /\ ((@IN (form -> Prop) a' sos) /\ (~ (tautologous a')))) \/ (exists c1 : form -> Prop, exists c2 : form -> Prop, exists p : form, (a' = (resolve p c1 c2)) /\ ((spresproof' c1) /\ (((spresproof' c2) \/ (@IN (form -> Prop) c2 hyps')) /\ ((@IN form p c1) /\ ((@IN form (FNot p) c2) /\ (~ (tautologous (resolve p c1 c2))))))))) -> spresproof' a') -> spresproof' a).
Proof. exact (eq_refl spresproof). Qed.
Definition sresproof : ((form -> Prop) -> Prop) -> ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop := fun hyps' : (form -> Prop) -> Prop => fun sos : (form -> Prop) -> Prop => fun a : form -> Prop => forall sresproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, (((@IN (form -> Prop) a' hyps') /\ ((@IN (form -> Prop) a' sos) /\ (~ (tautologous a')))) \/ (exists cl1 : form -> Prop, exists cl2 : form -> Prop, exists cl2' : form -> Prop, exists ps1 : form -> Prop, exists ps2 : form -> Prop, exists i : N -> term, (a' = (@IMAGE form form (formsubst i) (@Ensembles.Union form (@Ensembles.Setminus form cl1 ps1) (@Ensembles.Setminus form cl2' ps2)))) /\ ((sresproof' cl1) /\ (((sresproof' cl2) \/ (@IN (form -> Prop) cl2 hyps')) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@Ensembles.Included form ps1 cl1) /\ ((@Ensembles.Included form ps2 cl2') /\ ((~ (ps1 = (@Ensembles.Empty_set form))) /\ ((~ (ps2 = (@Ensembles.Empty_set form))) /\ ((exists i' : N -> term, Unifies i' (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_589 : form => exists p : form, @SETSPEC form GEN_PVAR_589 (@IN form p ps2) (FNot p))))) /\ (((mgu (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_590 : form => exists p : form, @SETSPEC form GEN_PVAR_590 (@IN form p ps2) (FNot p))))) = i) /\ (~ (tautologous (@IMAGE form form (formsubst i) (@Ensembles.Union form (@Ensembles.Setminus form cl1 ps1) (@Ensembles.Setminus form cl2' ps2)))))))))))))))) -> sresproof' a') -> sresproof' a.
Lemma sresproof_def : sresproof = (fun hyps' : (form -> Prop) -> Prop => fun sos : (form -> Prop) -> Prop => fun a : form -> Prop => forall sresproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, (((@IN (form -> Prop) a' hyps') /\ ((@IN (form -> Prop) a' sos) /\ (~ (tautologous a')))) \/ (exists cl1 : form -> Prop, exists cl2 : form -> Prop, exists cl2' : form -> Prop, exists ps1 : form -> Prop, exists ps2 : form -> Prop, exists i : N -> term, (a' = (@IMAGE form form (formsubst i) (@Ensembles.Union form (@Ensembles.Setminus form cl1 ps1) (@Ensembles.Setminus form cl2' ps2)))) /\ ((sresproof' cl1) /\ (((sresproof' cl2) \/ (@IN (form -> Prop) cl2 hyps')) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@Ensembles.Included form ps1 cl1) /\ ((@Ensembles.Included form ps2 cl2') /\ ((~ (ps1 = (@Ensembles.Empty_set form))) /\ ((~ (ps2 = (@Ensembles.Empty_set form))) /\ ((exists i' : N -> term, Unifies i' (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_589 : form => exists p : form, @SETSPEC form GEN_PVAR_589 (@IN form p ps2) (FNot p))))) /\ (((mgu (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_590 : form => exists p : form, @SETSPEC form GEN_PVAR_590 (@IN form p ps2) (FNot p))))) = i) /\ (~ (tautologous (@IMAGE form form (formsubst i) (@Ensembles.Union form (@Ensembles.Setminus form cl1 ps1) (@Ensembles.Setminus form cl2' ps2)))))))))))))))) -> sresproof' a') -> sresproof' a).
Proof. exact (eq_refl sresproof). Qed.
Definition allpositive : (form -> Prop) -> Prop := fun _460164 : form -> Prop => forall p : form, (@IN form p _460164) -> positive p.
Lemma allpositive_def : allpositive = (fun _460164 : form -> Prop => forall p : form, (@IN form p _460164) -> positive p).
Proof. exact (eq_refl allpositive). Qed.
Definition pposresproof : ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop := fun hyps' : (form -> Prop) -> Prop => fun a : form -> Prop => forall pposresproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, ((@IN (form -> Prop) a' hyps') \/ (exists p : form, exists cl1 : form -> Prop, exists cl2 : form -> Prop, (a' = (resolve p cl1 cl2)) /\ ((pposresproof' cl1) /\ ((pposresproof' cl2) /\ (((allpositive cl1) \/ (allpositive cl2)) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2))))))) -> pposresproof' a') -> pposresproof' a.
Lemma pposresproof_def : pposresproof = (fun hyps' : (form -> Prop) -> Prop => fun a : form -> Prop => forall pposresproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, ((@IN (form -> Prop) a' hyps') \/ (exists p : form, exists cl1 : form -> Prop, exists cl2 : form -> Prop, (a' = (resolve p cl1 cl2)) /\ ((pposresproof' cl1) /\ ((pposresproof' cl2) /\ (((allpositive cl1) \/ (allpositive cl2)) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2))))))) -> pposresproof' a') -> pposresproof' a).
Proof. exact (eq_refl pposresproof). Qed.
Definition psemresproof : (form -> Prop) -> ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop := fun v : form -> Prop => fun hyps' : (form -> Prop) -> Prop => fun a : form -> Prop => forall psemresproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, ((@IN (form -> Prop) a' hyps') \/ (exists p : form, exists cl1 : form -> Prop, exists cl2 : form -> Prop, (a' = (resolve p cl1 cl2)) /\ ((psemresproof' cl1) /\ ((psemresproof' cl2) /\ (((~ (pholds v (interp cl1))) \/ (~ (pholds v (interp cl2)))) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2))))))) -> psemresproof' a') -> psemresproof' a.
Lemma psemresproof_def : psemresproof = (fun v : form -> Prop => fun hyps' : (form -> Prop) -> Prop => fun a : form -> Prop => forall psemresproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, ((@IN (form -> Prop) a' hyps') \/ (exists p : form, exists cl1 : form -> Prop, exists cl2 : form -> Prop, (a' = (resolve p cl1 cl2)) /\ ((psemresproof' cl1) /\ ((psemresproof' cl2) /\ (((~ (pholds v (interp cl1))) \/ (~ (pholds v (interp cl2)))) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2))))))) -> psemresproof' a') -> psemresproof' a).
Proof. exact (eq_refl psemresproof). Qed.
Definition propflip : (form -> Prop) -> form -> form := fun _467005 : form -> Prop => fun _467006 : form => @COND form ((negative _467006) = (pholds _467005 _467006)) _467006 (FNot _467006).
Lemma propflip_def : propflip = (fun _467005 : form -> Prop => fun _467006 : form => @COND form ((negative _467006) = (pholds _467005 _467006)) _467006 (FNot _467006)).
Proof. exact (eq_refl propflip). Qed.
Definition posresproof : ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop := fun hyps' : (form -> Prop) -> Prop => fun a : form -> Prop => forall posresproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, ((@IN (form -> Prop) a' hyps') \/ (exists cl1 : form -> Prop, exists cl2 : form -> Prop, exists cl2' : form -> Prop, exists ps1 : form -> Prop, exists ps2 : form -> Prop, exists i : N -> term, (a' = (@IMAGE form form (formsubst i) (@Ensembles.Union form (@Ensembles.Setminus form cl1 ps1) (@Ensembles.Setminus form cl2' ps2)))) /\ ((posresproof' cl1) /\ ((posresproof' cl2) /\ (((allpositive cl1) \/ (allpositive cl2)) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@Ensembles.Included form ps1 cl1) /\ ((@Ensembles.Included form ps2 cl2') /\ ((~ (ps1 = (@Ensembles.Empty_set form))) /\ ((~ (ps2 = (@Ensembles.Empty_set form))) /\ ((exists i' : N -> term, Unifies i' (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_622 : form => exists p : form, @SETSPEC form GEN_PVAR_622 (@IN form p ps2) (FNot p))))) /\ ((mgu (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_623 : form => exists p : form, @SETSPEC form GEN_PVAR_623 (@IN form p ps2) (FNot p))))) = i)))))))))))) -> posresproof' a') -> posresproof' a.
Lemma posresproof_def : posresproof = (fun hyps' : (form -> Prop) -> Prop => fun a : form -> Prop => forall posresproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, ((@IN (form -> Prop) a' hyps') \/ (exists cl1 : form -> Prop, exists cl2 : form -> Prop, exists cl2' : form -> Prop, exists ps1 : form -> Prop, exists ps2 : form -> Prop, exists i : N -> term, (a' = (@IMAGE form form (formsubst i) (@Ensembles.Union form (@Ensembles.Setminus form cl1 ps1) (@Ensembles.Setminus form cl2' ps2)))) /\ ((posresproof' cl1) /\ ((posresproof' cl2) /\ (((allpositive cl1) \/ (allpositive cl2)) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@Ensembles.Included form ps1 cl1) /\ ((@Ensembles.Included form ps2 cl2') /\ ((~ (ps1 = (@Ensembles.Empty_set form))) /\ ((~ (ps2 = (@Ensembles.Empty_set form))) /\ ((exists i' : N -> term, Unifies i' (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_622 : form => exists p : form, @SETSPEC form GEN_PVAR_622 (@IN form p ps2) (FNot p))))) /\ ((mgu (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_623 : form => exists p : form, @SETSPEC form GEN_PVAR_623 (@IN form p ps2) (FNot p))))) = i)))))))))))) -> posresproof' a') -> posresproof' a).
Proof. exact (eq_refl posresproof). Qed.
Definition semresproof {A : Type'} : (prod (A -> Prop) (prod (N -> (list A) -> A) (N -> (list A) -> Prop))) -> ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop := fun M : prod (A -> Prop) (prod (N -> (list A) -> A) (N -> (list A) -> Prop)) => fun hyps' : (form -> Prop) -> Prop => fun a : form -> Prop => forall semresproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, ((@IN (form -> Prop) a' hyps') \/ (exists cl1 : form -> Prop, exists cl2 : form -> Prop, exists cl2' : form -> Prop, exists ps1 : form -> Prop, exists ps2 : form -> Prop, exists i : N -> term, (a' = (@IMAGE form form (formsubst i) (@Ensembles.Union form (@Ensembles.Setminus form cl1 ps1) (@Ensembles.Setminus form cl2' ps2)))) /\ ((semresproof' cl1) /\ ((semresproof' cl2) /\ (((~ (forall v : N -> A, @holds A M v (interp cl1))) \/ (~ (forall v : N -> A, @holds A M v (interp cl2)))) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@Ensembles.Included form ps1 cl1) /\ ((@Ensembles.Included form ps2 cl2') /\ ((~ (ps1 = (@Ensembles.Empty_set form))) /\ ((~ (ps2 = (@Ensembles.Empty_set form))) /\ ((exists i' : N -> term, Unifies i' (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_629 : form => exists p : form, @SETSPEC form GEN_PVAR_629 (@IN form p ps2) (FNot p))))) /\ ((mgu (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_630 : form => exists p : form, @SETSPEC form GEN_PVAR_630 (@IN form p ps2) (FNot p))))) = i)))))))))))) -> semresproof' a') -> semresproof' a.
Lemma semresproof_def {A : Type'} : (@semresproof A) = (fun M : prod (A -> Prop) (prod (N -> (list A) -> A) (N -> (list A) -> Prop)) => fun hyps' : (form -> Prop) -> Prop => fun a : form -> Prop => forall semresproof' : (form -> Prop) -> Prop, (forall a' : form -> Prop, ((@IN (form -> Prop) a' hyps') \/ (exists cl1 : form -> Prop, exists cl2 : form -> Prop, exists cl2' : form -> Prop, exists ps1 : form -> Prop, exists ps2 : form -> Prop, exists i : N -> term, (a' = (@IMAGE form form (formsubst i) (@Ensembles.Union form (@Ensembles.Setminus form cl1 ps1) (@Ensembles.Setminus form cl2' ps2)))) /\ ((semresproof' cl1) /\ ((semresproof' cl2) /\ (((~ (forall v : N -> A, @holds A M v (interp cl1))) \/ (~ (forall v : N -> A, @holds A M v (interp cl2)))) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@Ensembles.Included form ps1 cl1) /\ ((@Ensembles.Included form ps2 cl2') /\ ((~ (ps1 = (@Ensembles.Empty_set form))) /\ ((~ (ps2 = (@Ensembles.Empty_set form))) /\ ((exists i' : N -> term, Unifies i' (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_629 : form => exists p : form, @SETSPEC form GEN_PVAR_629 (@IN form p ps2) (FNot p))))) /\ ((mgu (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_630 : form => exists p : form, @SETSPEC form GEN_PVAR_630 (@IN form p ps2) (FNot p))))) = i)))))))))))) -> semresproof' a') -> semresproof' a).
Proof. exact (eq_refl (@semresproof A)). Qed.
Definition semresproof2 {A : Type'} : (prod (A -> Prop) (prod (N -> (list A) -> A) (N -> (list A) -> Prop))) -> ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop := fun M : prod (A -> Prop) (prod (N -> (list A) -> A) (N -> (list A) -> Prop)) => fun hyps' : (form -> Prop) -> Prop => fun a : form -> Prop => forall semresproof2' : (form -> Prop) -> Prop, (forall a' : form -> Prop, ((@IN (form -> Prop) a' hyps') \/ (exists cl1 : form -> Prop, exists cl2 : form -> Prop, exists cl2' : form -> Prop, exists ps1 : form -> Prop, exists ps2 : form -> Prop, exists i : N -> term, (a' = (@IMAGE form form (formsubst i) (@Ensembles.Union form (@Ensembles.Setminus form cl1 ps1) (@Ensembles.Setminus form cl2' ps2)))) /\ ((semresproof2' cl1) /\ ((semresproof2' cl2) /\ (((~ (forall v : N -> A, (@valuation A M v) -> @holds A M v (interp cl1))) \/ (~ (forall v : N -> A, (@valuation A M v) -> @holds A M v (interp cl2)))) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@Ensembles.Included form ps1 cl1) /\ ((@Ensembles.Included form ps2 cl2') /\ ((~ (ps1 = (@Ensembles.Empty_set form))) /\ ((~ (ps2 = (@Ensembles.Empty_set form))) /\ ((exists i' : N -> term, Unifies i' (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_636 : form => exists p : form, @SETSPEC form GEN_PVAR_636 (@IN form p ps2) (FNot p))))) /\ ((mgu (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_637 : form => exists p : form, @SETSPEC form GEN_PVAR_637 (@IN form p ps2) (FNot p))))) = i)))))))))))) -> semresproof2' a') -> semresproof2' a.
Lemma semresproof2_def {A : Type'} : (@semresproof2 A) = (fun M : prod (A -> Prop) (prod (N -> (list A) -> A) (N -> (list A) -> Prop)) => fun hyps' : (form -> Prop) -> Prop => fun a : form -> Prop => forall semresproof2' : (form -> Prop) -> Prop, (forall a' : form -> Prop, ((@IN (form -> Prop) a' hyps') \/ (exists cl1 : form -> Prop, exists cl2 : form -> Prop, exists cl2' : form -> Prop, exists ps1 : form -> Prop, exists ps2 : form -> Prop, exists i : N -> term, (a' = (@IMAGE form form (formsubst i) (@Ensembles.Union form (@Ensembles.Setminus form cl1 ps1) (@Ensembles.Setminus form cl2' ps2)))) /\ ((semresproof2' cl1) /\ ((semresproof2' cl2) /\ (((~ (forall v : N -> A, (@valuation A M v) -> @holds A M v (interp cl1))) \/ (~ (forall v : N -> A, (@valuation A M v) -> @holds A M v (interp cl2)))) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@Ensembles.Included form ps1 cl1) /\ ((@Ensembles.Included form ps2 cl2') /\ ((~ (ps1 = (@Ensembles.Empty_set form))) /\ ((~ (ps2 = (@Ensembles.Empty_set form))) /\ ((exists i' : N -> term, Unifies i' (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_636 : form => exists p : form, @SETSPEC form GEN_PVAR_636 (@IN form p ps2) (FNot p))))) /\ ((mgu (@Ensembles.Union form ps1 (@GSPEC form (fun GEN_PVAR_637 : form => exists p : form, @SETSPEC form GEN_PVAR_637 (@IN form p ps2) (FNot p))))) = i)))))))))))) -> semresproof2' a') -> semresproof2' a).
Proof. exact (eq_refl (@semresproof2 A)). Qed.
Definition isaresolvent_sem : (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (form -> Prop) -> (prod (form -> Prop) (form -> Prop)) -> Prop := fun _533128 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _533129 : form -> Prop => fun _533130 : prod (form -> Prop) (form -> Prop) => (isaresolvent _533129 (@pair (form -> Prop) (form -> Prop) (@fst (form -> Prop) (form -> Prop) _533130) (@snd (form -> Prop) (form -> Prop) _533130))) /\ ((~ (forall v : N -> N, @holds N _533128 v (interp (@fst (form -> Prop) (form -> Prop) _533130)))) \/ (~ (forall v : N -> N, @holds N _533128 v (interp (@snd (form -> Prop) (form -> Prop) _533130))))).
Lemma isaresolvent_sem_def : isaresolvent_sem = (fun _533128 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _533129 : form -> Prop => fun _533130 : prod (form -> Prop) (form -> Prop) => (isaresolvent _533129 (@pair (form -> Prop) (form -> Prop) (@fst (form -> Prop) (form -> Prop) _533130) (@snd (form -> Prop) (form -> Prop) _533130))) /\ ((~ (forall v : N -> N, @holds N _533128 v (interp (@fst (form -> Prop) (form -> Prop) _533130)))) \/ (~ (forall v : N -> N, @holds N _533128 v (interp (@snd (form -> Prop) (form -> Prop) _533130)))))).
Proof. exact (eq_refl isaresolvent_sem). Qed.
Definition allresolvents_sem : (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> ((form -> Prop) -> Prop) -> ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop := fun _533155 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _533156 : (form -> Prop) -> Prop => fun _533157 : (form -> Prop) -> Prop => @GSPEC (form -> Prop) (fun GEN_PVAR_648 : form -> Prop => exists c : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_648 (exists c1 : form -> Prop, exists c2 : form -> Prop, (@IN (form -> Prop) c1 _533156) /\ ((@IN (form -> Prop) c2 _533157) /\ (isaresolvent_sem _533155 c (@pair (form -> Prop) (form -> Prop) c1 c2)))) c).
Lemma allresolvents_sem_def : allresolvents_sem = (fun _533155 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _533156 : (form -> Prop) -> Prop => fun _533157 : (form -> Prop) -> Prop => @GSPEC (form -> Prop) (fun GEN_PVAR_648 : form -> Prop => exists c : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_648 (exists c1 : form -> Prop, exists c2 : form -> Prop, (@IN (form -> Prop) c1 _533156) /\ ((@IN (form -> Prop) c2 _533157) /\ (isaresolvent_sem _533155 c (@pair (form -> Prop) (form -> Prop) c1 c2)))) c)).
Proof. exact (eq_refl allresolvents_sem). Qed.
Definition allntresolvents_sem : (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> ((form -> Prop) -> Prop) -> ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop := fun _533176 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _533177 : (form -> Prop) -> Prop => fun _533178 : (form -> Prop) -> Prop => @GSPEC (form -> Prop) (fun GEN_PVAR_649 : form -> Prop => exists r : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_649 ((@IN (form -> Prop) r (allresolvents_sem _533176 _533177 _533178)) /\ (~ (tautologous r))) r).
Lemma allntresolvents_sem_def : allntresolvents_sem = (fun _533176 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _533177 : (form -> Prop) -> Prop => fun _533178 : (form -> Prop) -> Prop => @GSPEC (form -> Prop) (fun GEN_PVAR_649 : form -> Prop => exists r : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_649 ((@IN (form -> Prop) r (allresolvents_sem _533176 _533177 _533178)) /\ (~ (tautologous r))) r)).
Proof. exact (eq_refl allntresolvents_sem). Qed.
Definition resolvents_sem : (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (form -> Prop) -> (list (form -> Prop)) -> list (form -> Prop) := fun _533232 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _533233 : form -> Prop => fun _533234 : list (form -> Prop) => @list_of_set (form -> Prop) (allresolvents_sem _533232 (@INSERT (form -> Prop) _533233 (@Ensembles.Empty_set (form -> Prop))) (@set_of_list (form -> Prop) _533234)).
Lemma resolvents_sem_def : resolvents_sem = (fun _533232 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _533233 : form -> Prop => fun _533234 : list (form -> Prop) => @list_of_set (form -> Prop) (allresolvents_sem _533232 (@INSERT (form -> Prop) _533233 (@Ensembles.Empty_set (form -> Prop))) (@set_of_list (form -> Prop) _533234))).
Proof. exact (eq_refl resolvents_sem). Qed.
Definition step_sem : (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> prod (list (form -> Prop)) (list (form -> Prop)) := fun _533275 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _533276 : prod (list (form -> Prop)) (list (form -> Prop)) => @COND (prod (list (form -> Prop)) (list (form -> Prop))) ((@snd (list (form -> Prop)) (list (form -> Prop)) _533276) = (@nil (form -> Prop))) (@pair (list (form -> Prop)) (list (form -> Prop)) (@fst (list (form -> Prop)) (list (form -> Prop)) _533276) (@snd (list (form -> Prop)) (list (form -> Prop)) _533276)) (@Basics.apply (list (form -> Prop)) (prod (list (form -> Prop)) (list (form -> Prop))) (fun new : list (form -> Prop) => @Datatypes.id (prod (list (form -> Prop)) (list (form -> Prop))) (@pair (list (form -> Prop)) (list (form -> Prop)) (@insert (form -> Prop) (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _533276)) (@fst (list (form -> Prop)) (list (form -> Prop)) _533276)) (@fold_right_with_perm_args (form -> Prop) (list (form -> Prop)) (incorporate (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _533276))) new (@HOLLight_Real_With_N.mappings.tl (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _533276))))) (resolvents_sem _533275 (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _533276)) (@cons (form -> Prop) (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _533276)) (@fst (list (form -> Prop)) (list (form -> Prop)) _533276)))).
Lemma step_sem_def : step_sem = (fun _533275 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _533276 : prod (list (form -> Prop)) (list (form -> Prop)) => @COND (prod (list (form -> Prop)) (list (form -> Prop))) ((@snd (list (form -> Prop)) (list (form -> Prop)) _533276) = (@nil (form -> Prop))) (@pair (list (form -> Prop)) (list (form -> Prop)) (@fst (list (form -> Prop)) (list (form -> Prop)) _533276) (@snd (list (form -> Prop)) (list (form -> Prop)) _533276)) (@Basics.apply (list (form -> Prop)) (prod (list (form -> Prop)) (list (form -> Prop))) (fun new : list (form -> Prop) => @Datatypes.id (prod (list (form -> Prop)) (list (form -> Prop))) (@pair (list (form -> Prop)) (list (form -> Prop)) (@insert (form -> Prop) (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _533276)) (@fst (list (form -> Prop)) (list (form -> Prop)) _533276)) (@fold_right_with_perm_args (form -> Prop) (list (form -> Prop)) (incorporate (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _533276))) new (@HOLLight_Real_With_N.mappings.tl (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _533276))))) (resolvents_sem _533275 (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _533276)) (@cons (form -> Prop) (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) _533276)) (@fst (list (form -> Prop)) (list (form -> Prop)) _533276))))).
Proof. exact (eq_refl step_sem). Qed.
Definition given_sem : (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> N -> (prod (list (form -> Prop)) (list (form -> Prop))) -> prod (list (form -> Prop)) (list (form -> Prop)) := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> N -> (prod (list (form -> Prop)) (list (form -> Prop))) -> prod (list (form -> Prop)) (list (form -> Prop))) (fun given_sem' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> N -> (prod (list (form -> Prop)) (list (form -> Prop))) -> prod (list (form -> Prop)) (list (form -> Prop)) => forall _533299 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))), (forall M : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)), forall p : prod (list (form -> Prop)) (list (form -> Prop)), (given_sem' _533299 M (NUMERAL N0) p) = p) /\ (forall M : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)), forall n : N, forall p : prod (list (form -> Prop)) (list (form -> Prop)), (given_sem' _533299 M (N.succ n) p) = (step_sem M (given_sem' _533299 M n p)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))))))))))).
Lemma given_sem_def : given_sem = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> N -> (prod (list (form -> Prop)) (list (form -> Prop))) -> prod (list (form -> Prop)) (list (form -> Prop))) (fun given_sem' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> N -> (prod (list (form -> Prop)) (list (form -> Prop))) -> prod (list (form -> Prop)) (list (form -> Prop)) => forall _533299 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))), (forall M : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)), forall p : prod (list (form -> Prop)) (list (form -> Prop)), (given_sem' _533299 M (NUMERAL N0) p) = p) /\ (forall M : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)), forall n : N, forall p : prod (list (form -> Prop)) (list (form -> Prop)), (given_sem' _533299 M (N.succ n) p) = (step_sem M (given_sem' _533299 M n p)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0))))))))))))))))).
Proof. exact (eq_refl given_sem). Qed.
Definition Used_SEM : (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop := fun _533300 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _533301 : prod (list (form -> Prop)) (list (form -> Prop)) => fun _533302 : N => @set_of_list (form -> Prop) (@fst (list (form -> Prop)) (list (form -> Prop)) (given_sem _533300 _533302 _533301)).
Lemma Used_SEM_def : Used_SEM = (fun _533300 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _533301 : prod (list (form -> Prop)) (list (form -> Prop)) => fun _533302 : N => @set_of_list (form -> Prop) (@fst (list (form -> Prop)) (list (form -> Prop)) (given_sem _533300 _533302 _533301))).
Proof. exact (eq_refl Used_SEM). Qed.
Definition Unused_SEM : (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop := fun _533321 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _533322 : prod (list (form -> Prop)) (list (form -> Prop)) => fun _533323 : N => @set_of_list (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given_sem _533321 _533323 _533322)).
Lemma Unused_SEM_def : Unused_SEM = (fun _533321 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _533322 : prod (list (form -> Prop)) (list (form -> Prop)) => fun _533323 : N => @set_of_list (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given_sem _533321 _533323 _533322))).
Proof. exact (eq_refl Unused_SEM). Qed.
Definition Sub_SEM : (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop) (fun Sub_SEM' : (prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop => forall _533349 : prod N (prod N (prod N (prod N (prod N (prod N N))))), (forall M : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)), forall init : prod (list (form -> Prop)) (list (form -> Prop)), (Sub_SEM' _533349 M init (NUMERAL N0)) = (@Ensembles.Empty_set (form -> Prop))) /\ (forall M : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)), forall init : prod (list (form -> Prop)) (list (form -> Prop)), forall n : N, (Sub_SEM' _533349 M init (N.succ n)) = (@COND ((form -> Prop) -> Prop) ((@snd (list (form -> Prop)) (list (form -> Prop)) (given_sem M n init)) = (@nil (form -> Prop))) (Sub_SEM' _533349 M init n) (@INSERT (form -> Prop) (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given_sem M n init))) (Sub_SEM' _533349 M init n))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))))))))).
Lemma Sub_SEM_def : Sub_SEM = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop) (fun Sub_SEM' : (prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop => forall _533349 : prod N (prod N (prod N (prod N (prod N (prod N N))))), (forall M : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)), forall init : prod (list (form -> Prop)) (list (form -> Prop)), (Sub_SEM' _533349 M init (NUMERAL N0)) = (@Ensembles.Empty_set (form -> Prop))) /\ (forall M : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)), forall init : prod (list (form -> Prop)) (list (form -> Prop)), forall n : N, (Sub_SEM' _533349 M init (N.succ n)) = (@COND ((form -> Prop) -> Prop) ((@snd (list (form -> Prop)) (list (form -> Prop)) (given_sem M n init)) = (@nil (form -> Prop))) (Sub_SEM' _533349 M init n) (@INSERT (form -> Prop) (@HOLLight_Real_With_N.mappings.hd (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given_sem M n init))) (Sub_SEM' _533349 M init n))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0))))))))))))))).
Proof. exact (eq_refl Sub_SEM). Qed.
Definition break_sem : (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> N := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> N) (fun break_sem' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> N => forall _544384 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))), (forall M : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)), forall init : prod (list (form -> Prop)) (list (form -> Prop)), (break_sem' _544384 M init (NUMERAL N0)) = (@lengthN (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given_sem M (NUMERAL N0) init)))) /\ (forall M : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)), forall n : N, forall init : prod (list (form -> Prop)) (list (form -> Prop)), (break_sem' _544384 M init (N.succ n)) = (N.add (break_sem' _544384 M init n) (@lengthN (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given_sem M (break_sem' _544384 M init n) init)))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))))))))))).
Lemma break_sem_def : break_sem = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> N) (fun break_sem' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> N => forall _544384 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))), (forall M : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)), forall init : prod (list (form -> Prop)) (list (form -> Prop)), (break_sem' _544384 M init (NUMERAL N0)) = (@lengthN (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given_sem M (NUMERAL N0) init)))) /\ (forall M : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)), forall n : N, forall init : prod (list (form -> Prop)) (list (form -> Prop)), (break_sem' _544384 M init (N.succ n)) = (N.add (break_sem' _544384 M init n) (@lengthN (form -> Prop) (@snd (list (form -> Prop)) (list (form -> Prop)) (given_sem M (break_sem' _544384 M init n) init)))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0))))))))))))))))).
Proof. exact (eq_refl break_sem). Qed.
Definition level_sem : (prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop))) -> (prod (list (form -> Prop)) (list (form -> Prop))) -> N -> (form -> Prop) -> Prop := fun _544385 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _544386 : prod (list (form -> Prop)) (list (form -> Prop)) => fun _544387 : N => Sub_SEM _544385 _544386 (break_sem _544385 _544386 _544387).
Lemma level_sem_def : level_sem = (fun _544385 : prod (N -> Prop) (prod (N -> (list N) -> N) (N -> (list N) -> Prop)) => fun _544386 : prod (list (form -> Prop)) (list (form -> Prop)) => fun _544387 : N => Sub_SEM _544385 _544386 (break_sem _544385 _544386 _544387)).
Proof. exact (eq_refl level_sem). Qed.
Definition definite : (form -> Prop) -> Prop := fun _545149 : form -> Prop => (clause _545149) /\ ((@CARD form (@GSPEC form (fun GEN_PVAR_652 : form => exists p : form, @SETSPEC form GEN_PVAR_652 ((@IN form p _545149) /\ (positive p)) p))) = (NUMERAL (BIT1 N0))).
Lemma definite_def : definite = (fun _545149 : form -> Prop => (clause _545149) /\ ((@CARD form (@GSPEC form (fun GEN_PVAR_652 : form => exists p : form, @SETSPEC form GEN_PVAR_652 ((@IN form p _545149) /\ (positive p)) p))) = (NUMERAL (BIT1 N0)))).
Proof. exact (eq_refl definite). Qed.
Definition horn : (form -> Prop) -> Prop := fun _545154 : form -> Prop => (clause _545154) /\ (N.le (@CARD form (@GSPEC form (fun GEN_PVAR_653 : form => exists p : form, @SETSPEC form GEN_PVAR_653 ((@IN form p _545154) /\ (positive p)) p))) (NUMERAL (BIT1 N0))).
Lemma horn_def : horn = (fun _545154 : form -> Prop => (clause _545154) /\ (N.le (@CARD form (@GSPEC form (fun GEN_PVAR_653 : form => exists p : form, @SETSPEC form GEN_PVAR_653 ((@IN form p _545154) /\ (positive p)) p))) (NUMERAL (BIT1 N0)))).
Proof. exact (eq_refl horn). Qed.
Definition falsify : form -> (form -> Prop) -> form -> Prop := fun _545159 : form => fun _545160 : form -> Prop => @COND (form -> Prop) (definite _545160) _545160 (@INSERT form _545159 _545160).
Lemma falsify_def : falsify = (fun _545159 : form => fun _545160 : form -> Prop => @COND (form -> Prop) (definite _545160) _545160 (@INSERT form _545159 _545160)).
Proof. exact (eq_refl falsify). Qed.
Definition minmodel : (form -> Prop) -> prod (term -> Prop) (prod (N -> (list term) -> term) (N -> (list term) -> Prop)) := fun _546187 : form -> Prop => @pair (term -> Prop) (prod (N -> (list term) -> term) (N -> (list term) -> Prop)) (herbase (functions _546187)) (@pair (N -> (list term) -> term) (N -> (list term) -> Prop) Fn (fun p : N => fun zs : list term => forall H : prod (term -> Prop) (prod (N -> (list term) -> term) (N -> (list term) -> Prop)), (((@Dom term H) = (herbase (functions _546187))) /\ (((@Fun term H) = Fn) /\ (@satisfies term H _546187))) -> @Pred term H p zs)).
Lemma minmodel_def : minmodel = (fun _546187 : form -> Prop => @pair (term -> Prop) (prod (N -> (list term) -> term) (N -> (list term) -> Prop)) (herbase (functions _546187)) (@pair (N -> (list term) -> term) (N -> (list term) -> Prop) Fn (fun p : N => fun zs : list term => forall H : prod (term -> Prop) (prod (N -> (list term) -> term) (N -> (list term) -> Prop)), (((@Dom term H) = (herbase (functions _546187))) /\ (((@Fun term H) = Fn) /\ (@satisfies term H _546187))) -> @Pred term H p zs))).
Proof. exact (eq_refl minmodel). Qed.
Definition breakhorn : (form -> Prop) -> prod (list form) form := fun _546245 : form -> Prop => @COND (prod (list form) form) (definite _546245) (@Basics.apply form (prod (list form) form) (fun p : form => @Datatypes.id (prod (list form) form) (@pair (list form) form (@List.map form form FNot (@list_of_set form (@Ensembles.Subtract form _546245 p))) p)) (@ε form (fun p : form => (@IN form p _546245) /\ (positive p)))) (@pair (list form) form (@List.map form form FNot (@list_of_set form _546245)) FFalse).
Lemma breakhorn_def : breakhorn = (fun _546245 : form -> Prop => @COND (prod (list form) form) (definite _546245) (@Basics.apply form (prod (list form) form) (fun p : form => @Datatypes.id (prod (list form) form) (@pair (list form) form (@List.map form form FNot (@list_of_set form (@Ensembles.Subtract form _546245 p))) p)) (@ε form (fun p : form => (@IN form p _546245) /\ (positive p)))) (@pair (list form) form (@List.map form form FNot (@list_of_set form _546245)) FFalse)).
Proof. exact (eq_refl breakhorn). Qed.
Definition hypotheses : (form -> Prop) -> list form := fun _546250 : form -> Prop => @fst (list form) form (breakhorn _546250).
Lemma hypotheses_def : hypotheses = (fun _546250 : form -> Prop => @fst (list form) form (breakhorn _546250)).
Proof. exact (eq_refl hypotheses). Qed.
Definition conclusion : (form -> Prop) -> form := fun _546255 : form -> Prop => @snd (list form) form (breakhorn _546255).
Lemma conclusion_def : conclusion = (fun _546255 : form -> Prop => @snd (list form) form (breakhorn _546255)).
Proof. exact (eq_refl conclusion). Qed.
Definition gbackchain : ((form -> Prop) -> Prop) -> N -> form -> Prop := fun s : (form -> Prop) -> Prop => fun a0 : N => fun a1 : form => forall gbackchain' : N -> form -> Prop, (forall a0' : N, forall a1' : form, (exists cl : form -> Prop, exists i : N -> term, exists ns : list N, (a0' = (@fold_right_with_perm_args N N N.add ns (NUMERAL (BIT1 N0)))) /\ ((a1' = (formsubst i (conclusion cl))) /\ ((@IN (form -> Prop) cl s) /\ ((forall x : N, @IN term (i x) (herbase (functions (@IMAGE (form -> Prop) form interp s)))) /\ (@List.Forall2 N form gbackchain' ns (@List.map form form (formsubst i) (hypotheses cl))))))) -> gbackchain' a0' a1') -> gbackchain' a0 a1.
Lemma gbackchain_def : gbackchain = (fun s : (form -> Prop) -> Prop => fun a0 : N => fun a1 : form => forall gbackchain' : N -> form -> Prop, (forall a0' : N, forall a1' : form, (exists cl : form -> Prop, exists i : N -> term, exists ns : list N, (a0' = (@fold_right_with_perm_args N N N.add ns (NUMERAL (BIT1 N0)))) /\ ((a1' = (formsubst i (conclusion cl))) /\ ((@IN (form -> Prop) cl s) /\ ((forall x : N, @IN term (i x) (herbase (functions (@IMAGE (form -> Prop) form interp s)))) /\ (@List.Forall2 N form gbackchain' ns (@List.map form form (formsubst i) (hypotheses cl))))))) -> gbackchain' a0' a1') -> gbackchain' a0 a1).
Proof. exact (eq_refl gbackchain). Qed.
Definition iminmodel : (form -> Prop) -> prod (term -> Prop) (prod (N -> (list term) -> term) (N -> (list term) -> Prop)) := fun _549309 : form -> Prop => @pair (term -> Prop) (prod (N -> (list term) -> term) (N -> (list term) -> Prop)) (terms (functions _549309)) (@pair (N -> (list term) -> term) (N -> (list term) -> Prop) Fn (fun p : N => fun zs : list term => forall C : prod (term -> Prop) (prod (N -> (list term) -> term) (N -> (list term) -> Prop)), (((@Dom term C) = (terms (functions _549309))) /\ (((@Fun term C) = Fn) /\ (forall v : N -> term, forall p' : form, ((@IN form p' _549309) /\ (@valuation term C v)) -> @holds term C v p'))) -> @Pred term C p zs)).
Lemma iminmodel_def : iminmodel = (fun _549309 : form -> Prop => @pair (term -> Prop) (prod (N -> (list term) -> term) (N -> (list term) -> Prop)) (terms (functions _549309)) (@pair (N -> (list term) -> term) (N -> (list term) -> Prop) Fn (fun p : N => fun zs : list term => forall C : prod (term -> Prop) (prod (N -> (list term) -> term) (N -> (list term) -> Prop)), (((@Dom term C) = (terms (functions _549309))) /\ (((@Fun term C) = Fn) /\ (forall v : N -> term, forall p' : form, ((@IN form p' _549309) /\ (@valuation term C v)) -> @holds term C v p'))) -> @Pred term C p zs))).
Proof. exact (eq_refl iminmodel). Qed.
Definition ibackchain : ((form -> Prop) -> Prop) -> N -> form -> Prop := fun s : (form -> Prop) -> Prop => fun a0 : N => fun a1 : form => forall ibackchain' : N -> form -> Prop, (forall a0' : N, forall a1' : form, (exists cl : form -> Prop, exists i : N -> term, exists ns : list N, (a0' = (@fold_right_with_perm_args N N N.add ns (NUMERAL (BIT1 N0)))) /\ ((a1' = (formsubst i (conclusion cl))) /\ ((@IN (form -> Prop) cl s) /\ ((forall x : N, @IN term (i x) (terms (functions (@IMAGE (form -> Prop) form interp s)))) /\ (@List.Forall2 N form ibackchain' ns (@List.map form form (formsubst i) (hypotheses cl))))))) -> ibackchain' a0' a1') -> ibackchain' a0 a1.
Lemma ibackchain_def : ibackchain = (fun s : (form -> Prop) -> Prop => fun a0 : N => fun a1 : form => forall ibackchain' : N -> form -> Prop, (forall a0' : N, forall a1' : form, (exists cl : form -> Prop, exists i : N -> term, exists ns : list N, (a0' = (@fold_right_with_perm_args N N N.add ns (NUMERAL (BIT1 N0)))) /\ ((a1' = (formsubst i (conclusion cl))) /\ ((@IN (form -> Prop) cl s) /\ ((forall x : N, @IN term (i x) (terms (functions (@IMAGE (form -> Prop) form interp s)))) /\ (@List.Forall2 N form ibackchain' ns (@List.map form form (formsubst i) (hypotheses cl))))))) -> ibackchain' a0' a1') -> ibackchain' a0 a1).
Proof. exact (eq_refl ibackchain). Qed.
Definition vdash : (form -> Prop) -> form -> Prop := fun E : form -> Prop => fun a : form => forall vdash' : form -> Prop, (forall a' : form, ((exists s : term, exists t : term, (a' = (FEq s t)) /\ (@IN form (FEq s t) E)) \/ ((exists t : term, a' = (FEq t t)) \/ ((exists s : term, exists t : term, (a' = (FEq t s)) /\ (vdash' (FEq s t))) \/ ((exists s : term, exists t : term, exists u : term, (a' = (FEq s u)) /\ ((vdash' (FEq s t)) /\ (vdash' (FEq t u)))) \/ ((exists f : N, exists a'' : list term, exists b : list term, (a' = (FEq (Fn f a'') (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash' (FEq l r)) a'' b)) \/ (exists s : term, exists t : term, exists i : N -> term, (a' = (formsubst i (FEq s t))) /\ (vdash' (FEq s t)))))))) -> vdash' a') -> vdash' a.
Lemma vdash_def : vdash = (fun E : form -> Prop => fun a : form => forall vdash' : form -> Prop, (forall a' : form, ((exists s : term, exists t : term, (a' = (FEq s t)) /\ (@IN form (FEq s t) E)) \/ ((exists t : term, a' = (FEq t t)) \/ ((exists s : term, exists t : term, (a' = (FEq t s)) /\ (vdash' (FEq s t))) \/ ((exists s : term, exists t : term, exists u : term, (a' = (FEq s u)) /\ ((vdash' (FEq s t)) /\ (vdash' (FEq t u)))) \/ ((exists f : N, exists a'' : list term, exists b : list term, (a' = (FEq (Fn f a'') (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash' (FEq l r)) a'' b)) \/ (exists s : term, exists t : term, exists i : N -> term, (a' = (formsubst i (FEq s t))) /\ (vdash' (FEq s t)))))))) -> vdash' a') -> vdash' a).
Proof. exact (eq_refl vdash). Qed.
Definition vdash2 : (form -> Prop) -> form -> Prop := fun E : form -> Prop => fun a : form => forall vdash2' : form -> Prop, (forall a' : form, ((exists s : term, exists t : term, exists i : N -> term, (a' = (formsubst i (FEq s t))) /\ (@IN form (FEq s t) E)) \/ ((exists s : term, exists t : term, exists i : N -> term, (a' = (formsubst i (FEq t s))) /\ (@IN form (FEq s t) E)) \/ ((exists t : term, a' = (FEq t t)) \/ ((exists s : term, exists t : term, exists u : term, (a' = (FEq s u)) /\ ((vdash2' (FEq s t)) /\ (vdash2' (FEq t u)))) \/ (exists f : N, exists a'' : list term, exists b : list term, (a' = (FEq (Fn f a'') (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash2' (FEq l r)) a'' b)))))) -> vdash2' a') -> vdash2' a.
Lemma vdash2_def : vdash2 = (fun E : form -> Prop => fun a : form => forall vdash2' : form -> Prop, (forall a' : form, ((exists s : term, exists t : term, exists i : N -> term, (a' = (formsubst i (FEq s t))) /\ (@IN form (FEq s t) E)) \/ ((exists s : term, exists t : term, exists i : N -> term, (a' = (formsubst i (FEq t s))) /\ (@IN form (FEq s t) E)) \/ ((exists t : term, a' = (FEq t t)) \/ ((exists s : term, exists t : term, exists u : term, (a' = (FEq s u)) /\ ((vdash2' (FEq s t)) /\ (vdash2' (FEq t u)))) \/ (exists f : N, exists a'' : list term, exists b : list term, (a' = (FEq (Fn f a'') (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash2' (FEq l r)) a'' b)))))) -> vdash2' a') -> vdash2' a).
Proof. exact (eq_refl vdash2). Qed.
Definition vdash2_axiom : (form -> Prop) -> form -> Prop := fun E : form -> Prop => fun a : form => forall vdash2_axiom' : form -> Prop, (forall a' : form, ((exists s : term, exists t : term, exists i : N -> term, (a' = (formsubst i (FEq s t))) /\ (@IN form (FEq s t) E)) \/ (exists s : term, exists t : term, exists i : N -> term, (a' = (formsubst i (FEq t s))) /\ (@IN form (FEq s t) E))) -> vdash2_axiom' a') -> vdash2_axiom' a.
Lemma vdash2_axiom_def : vdash2_axiom = (fun E : form -> Prop => fun a : form => forall vdash2_axiom' : form -> Prop, (forall a' : form, ((exists s : term, exists t : term, exists i : N -> term, (a' = (formsubst i (FEq s t))) /\ (@IN form (FEq s t) E)) \/ (exists s : term, exists t : term, exists i : N -> term, (a' = (formsubst i (FEq t s))) /\ (@IN form (FEq s t) E))) -> vdash2_axiom' a') -> vdash2_axiom' a).
Proof. exact (eq_refl vdash2_axiom). Qed.
Definition vdash3 : (form -> Prop) -> form -> Prop := fun E : form -> Prop => fun a3 : form => forall vdash2_achain' : form -> Prop, forall vdash2_cchain' : form -> Prop, forall vdash2_cong' : form -> Prop, forall vdash3' : form -> Prop, ((forall a0 : form, ((exists s : term, exists t : term, (a0 = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0 = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ (vdash3' (FEq t u))))) -> vdash2_achain' a0) /\ ((forall a1 : form, ((exists s : term, exists t : term, (a1 = (FEq s t)) /\ (vdash2_cong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1 = (FEq s u)) /\ ((vdash2_cong' (FEq s t)) /\ (vdash2_achain' (FEq t u))))) -> vdash2_cchain' a1) /\ ((forall a2 : form, (exists f : N, exists a : list term, exists b : list term, (a2 = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash3' (FEq l r)) a b)) -> vdash2_cong' a2) /\ (forall a3' : form, (exists s : term, exists t : term, (a3' = (FEq s t)) /\ ((s = t) \/ ((vdash2_achain' (FEq s t)) \/ (vdash2_cchain' (FEq s t))))) -> vdash3' a3')))) -> vdash3' a3.
Lemma vdash3_def : vdash3 = (fun E : form -> Prop => fun a3 : form => forall vdash2_achain' : form -> Prop, forall vdash2_cchain' : form -> Prop, forall vdash2_cong' : form -> Prop, forall vdash3' : form -> Prop, ((forall a0 : form, ((exists s : term, exists t : term, (a0 = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0 = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ (vdash3' (FEq t u))))) -> vdash2_achain' a0) /\ ((forall a1 : form, ((exists s : term, exists t : term, (a1 = (FEq s t)) /\ (vdash2_cong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1 = (FEq s u)) /\ ((vdash2_cong' (FEq s t)) /\ (vdash2_achain' (FEq t u))))) -> vdash2_cchain' a1) /\ ((forall a2 : form, (exists f : N, exists a : list term, exists b : list term, (a2 = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash3' (FEq l r)) a b)) -> vdash2_cong' a2) /\ (forall a3' : form, (exists s : term, exists t : term, (a3' = (FEq s t)) /\ ((s = t) \/ ((vdash2_achain' (FEq s t)) \/ (vdash2_cchain' (FEq s t))))) -> vdash3' a3')))) -> vdash3' a3).
Proof. exact (eq_refl vdash3). Qed.
Definition vdash2_achain : (form -> Prop) -> form -> Prop := fun E : form -> Prop => fun a0 : form => forall vdash2_achain' : form -> Prop, forall vdash2_cchain' : form -> Prop, forall vdash2_cong' : form -> Prop, forall vdash3' : form -> Prop, ((forall a0' : form, ((exists s : term, exists t : term, (a0' = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0' = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ (vdash3' (FEq t u))))) -> vdash2_achain' a0') /\ ((forall a1 : form, ((exists s : term, exists t : term, (a1 = (FEq s t)) /\ (vdash2_cong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1 = (FEq s u)) /\ ((vdash2_cong' (FEq s t)) /\ (vdash2_achain' (FEq t u))))) -> vdash2_cchain' a1) /\ ((forall a2 : form, (exists f : N, exists a : list term, exists b : list term, (a2 = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash3' (FEq l r)) a b)) -> vdash2_cong' a2) /\ (forall a3 : form, (exists s : term, exists t : term, (a3 = (FEq s t)) /\ ((s = t) \/ ((vdash2_achain' (FEq s t)) \/ (vdash2_cchain' (FEq s t))))) -> vdash3' a3)))) -> vdash2_achain' a0.
Lemma vdash2_achain_def : vdash2_achain = (fun E : form -> Prop => fun a0 : form => forall vdash2_achain' : form -> Prop, forall vdash2_cchain' : form -> Prop, forall vdash2_cong' : form -> Prop, forall vdash3' : form -> Prop, ((forall a0' : form, ((exists s : term, exists t : term, (a0' = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0' = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ (vdash3' (FEq t u))))) -> vdash2_achain' a0') /\ ((forall a1 : form, ((exists s : term, exists t : term, (a1 = (FEq s t)) /\ (vdash2_cong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1 = (FEq s u)) /\ ((vdash2_cong' (FEq s t)) /\ (vdash2_achain' (FEq t u))))) -> vdash2_cchain' a1) /\ ((forall a2 : form, (exists f : N, exists a : list term, exists b : list term, (a2 = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash3' (FEq l r)) a b)) -> vdash2_cong' a2) /\ (forall a3 : form, (exists s : term, exists t : term, (a3 = (FEq s t)) /\ ((s = t) \/ ((vdash2_achain' (FEq s t)) \/ (vdash2_cchain' (FEq s t))))) -> vdash3' a3)))) -> vdash2_achain' a0).
Proof. exact (eq_refl vdash2_achain). Qed.
Definition vdash2_cchain : (form -> Prop) -> form -> Prop := fun E : form -> Prop => fun a1 : form => forall vdash2_achain' : form -> Prop, forall vdash2_cchain' : form -> Prop, forall vdash2_cong' : form -> Prop, forall vdash3' : form -> Prop, ((forall a0 : form, ((exists s : term, exists t : term, (a0 = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0 = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ (vdash3' (FEq t u))))) -> vdash2_achain' a0) /\ ((forall a1' : form, ((exists s : term, exists t : term, (a1' = (FEq s t)) /\ (vdash2_cong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1' = (FEq s u)) /\ ((vdash2_cong' (FEq s t)) /\ (vdash2_achain' (FEq t u))))) -> vdash2_cchain' a1') /\ ((forall a2 : form, (exists f : N, exists a : list term, exists b : list term, (a2 = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash3' (FEq l r)) a b)) -> vdash2_cong' a2) /\ (forall a3 : form, (exists s : term, exists t : term, (a3 = (FEq s t)) /\ ((s = t) \/ ((vdash2_achain' (FEq s t)) \/ (vdash2_cchain' (FEq s t))))) -> vdash3' a3)))) -> vdash2_cchain' a1.
Lemma vdash2_cchain_def : vdash2_cchain = (fun E : form -> Prop => fun a1 : form => forall vdash2_achain' : form -> Prop, forall vdash2_cchain' : form -> Prop, forall vdash2_cong' : form -> Prop, forall vdash3' : form -> Prop, ((forall a0 : form, ((exists s : term, exists t : term, (a0 = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0 = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ (vdash3' (FEq t u))))) -> vdash2_achain' a0) /\ ((forall a1' : form, ((exists s : term, exists t : term, (a1' = (FEq s t)) /\ (vdash2_cong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1' = (FEq s u)) /\ ((vdash2_cong' (FEq s t)) /\ (vdash2_achain' (FEq t u))))) -> vdash2_cchain' a1') /\ ((forall a2 : form, (exists f : N, exists a : list term, exists b : list term, (a2 = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash3' (FEq l r)) a b)) -> vdash2_cong' a2) /\ (forall a3 : form, (exists s : term, exists t : term, (a3 = (FEq s t)) /\ ((s = t) \/ ((vdash2_achain' (FEq s t)) \/ (vdash2_cchain' (FEq s t))))) -> vdash3' a3)))) -> vdash2_cchain' a1).
Proof. exact (eq_refl vdash2_cchain). Qed.
Definition vdash2_cong : (form -> Prop) -> form -> Prop := fun E : form -> Prop => fun a2 : form => forall vdash2_achain' : form -> Prop, forall vdash2_cchain' : form -> Prop, forall vdash2_cong' : form -> Prop, forall vdash3' : form -> Prop, ((forall a0 : form, ((exists s : term, exists t : term, (a0 = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0 = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ (vdash3' (FEq t u))))) -> vdash2_achain' a0) /\ ((forall a1 : form, ((exists s : term, exists t : term, (a1 = (FEq s t)) /\ (vdash2_cong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1 = (FEq s u)) /\ ((vdash2_cong' (FEq s t)) /\ (vdash2_achain' (FEq t u))))) -> vdash2_cchain' a1) /\ ((forall a2' : form, (exists f : N, exists a : list term, exists b : list term, (a2' = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash3' (FEq l r)) a b)) -> vdash2_cong' a2') /\ (forall a3 : form, (exists s : term, exists t : term, (a3 = (FEq s t)) /\ ((s = t) \/ ((vdash2_achain' (FEq s t)) \/ (vdash2_cchain' (FEq s t))))) -> vdash3' a3)))) -> vdash2_cong' a2.
Lemma vdash2_cong_def : vdash2_cong = (fun E : form -> Prop => fun a2 : form => forall vdash2_achain' : form -> Prop, forall vdash2_cchain' : form -> Prop, forall vdash2_cong' : form -> Prop, forall vdash3' : form -> Prop, ((forall a0 : form, ((exists s : term, exists t : term, (a0 = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0 = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ (vdash3' (FEq t u))))) -> vdash2_achain' a0) /\ ((forall a1 : form, ((exists s : term, exists t : term, (a1 = (FEq s t)) /\ (vdash2_cong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1 = (FEq s u)) /\ ((vdash2_cong' (FEq s t)) /\ (vdash2_achain' (FEq t u))))) -> vdash2_cchain' a1) /\ ((forall a2' : form, (exists f : N, exists a : list term, exists b : list term, (a2' = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash3' (FEq l r)) a b)) -> vdash2_cong' a2') /\ (forall a3 : form, (exists s : term, exists t : term, (a3 = (FEq s t)) /\ ((s = t) \/ ((vdash2_achain' (FEq s t)) \/ (vdash2_cchain' (FEq s t))))) -> vdash3' a3)))) -> vdash2_cong' a2).
Proof. exact (eq_refl vdash2_cong). Qed.
Definition subterms : term -> term -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> term -> term -> Prop) (fun subterms' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> term -> term -> Prop => forall _553739 : prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))), (forall x : N, (subterms' _553739 (V x)) = (@INSERT term (V x) (@Ensembles.Empty_set term))) /\ (forall f : N, forall args : list term, (subterms' _553739 (Fn f args)) = (@INSERT term (Fn f args) (@list_Union term (@List.map term (term -> Prop) (subterms' _553739) args))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0))))))))))))))).
Lemma subterms_def : subterms = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> term -> term -> Prop) (fun subterms' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> term -> term -> Prop => forall _553739 : prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))), (forall x : N, (subterms' _553739 (V x)) = (@INSERT term (V x) (@Ensembles.Empty_set term))) /\ (forall f : N, forall args : list term, (subterms' _553739 (Fn f args)) = (@INSERT term (Fn f args) (@list_Union term (@List.map term (term -> Prop) (subterms' _553739) args))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))))))))))).
Proof. exact (eq_refl subterms). Qed.
Definition subtermsa : form -> term -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> form -> term -> Prop) (fun subtermsa' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> form -> term -> Prop => forall _553741 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))), forall P : N, forall args : list term, (subtermsa' _553741 (Atom P args)) = (@list_Union term (@List.map term (term -> Prop) subterms args))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))))))))))).
Lemma subtermsa_def : subtermsa = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> form -> term -> Prop) (fun subtermsa' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> form -> term -> Prop => forall _553741 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))), forall P : N, forall args : list term, (subtermsa' _553741 (Atom P args)) = (@list_Union term (@List.map term (term -> Prop) subterms args))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 N0))))))))))))))))).
Proof. exact (eq_refl subtermsa). Qed.
Definition subtermss : (form -> Prop) -> term -> Prop := fun _553742 : form -> Prop => @UNIONS term (@GSPEC (term -> Prop) (fun GEN_PVAR_664 : term -> Prop => exists p : form, @SETSPEC (term -> Prop) GEN_PVAR_664 (@IN form p _553742) (subtermsa p))).
Lemma subtermss_def : subtermss = (fun _553742 : form -> Prop => @UNIONS term (@GSPEC (term -> Prop) (fun GEN_PVAR_664 : term -> Prop => exists p : form, @SETSPEC (term -> Prop) GEN_PVAR_664 (@IN form p _553742) (subtermsa p)))).
Proof. exact (eq_refl subtermss). Qed.
Definition esubterms : (form -> Prop) -> term -> term -> term -> Prop := fun _553747 : form -> Prop => fun _553748 : term => fun _553749 : term => subtermss (@INSERT form (FEq _553748 _553749) (@GSPEC form (fun GEN_PVAR_665 : form => exists i : N -> term, exists p : form, @SETSPEC form GEN_PVAR_665 (@IN form p _553747) (formsubst i p)))).
Lemma esubterms_def : esubterms = (fun _553747 : form -> Prop => fun _553748 : term => fun _553749 : term => subtermss (@INSERT form (FEq _553748 _553749) (@GSPEC form (fun GEN_PVAR_665 : form => exists i : N -> term, exists p : form, @SETSPEC form GEN_PVAR_665 (@IN form p _553747) (formsubst i p))))).
Proof. exact (eq_refl esubterms). Qed.
Definition vdash4 : (form -> Prop) -> form -> Prop := fun E : form -> Prop => fun a3 : form => forall vdash2_sachain' : form -> Prop, forall vdash2_scchain' : form -> Prop, forall vdash2_scong' : form -> Prop, forall vdash4' : form -> Prop, ((forall a0 : form, ((exists s : term, exists t : term, (a0 = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0 = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ ((vdash4' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_sachain' a0) /\ ((forall a1 : form, ((exists s : term, exists t : term, (a1 = (FEq s t)) /\ (vdash2_scong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1 = (FEq s u)) /\ ((vdash2_scong' (FEq s t)) /\ ((vdash2_sachain' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_scchain' a1) /\ ((forall a2 : form, (exists f : N, exists a : list term, exists b : list term, (a2 = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash4' (FEq l r)) a b)) -> vdash2_scong' a2) /\ (forall a3' : form, (exists s : term, exists t : term, (a3' = (FEq s t)) /\ ((s = t) \/ ((vdash2_sachain' (FEq s t)) \/ (vdash2_scchain' (FEq s t))))) -> vdash4' a3')))) -> vdash4' a3.
Lemma vdash4_def : vdash4 = (fun E : form -> Prop => fun a3 : form => forall vdash2_sachain' : form -> Prop, forall vdash2_scchain' : form -> Prop, forall vdash2_scong' : form -> Prop, forall vdash4' : form -> Prop, ((forall a0 : form, ((exists s : term, exists t : term, (a0 = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0 = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ ((vdash4' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_sachain' a0) /\ ((forall a1 : form, ((exists s : term, exists t : term, (a1 = (FEq s t)) /\ (vdash2_scong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1 = (FEq s u)) /\ ((vdash2_scong' (FEq s t)) /\ ((vdash2_sachain' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_scchain' a1) /\ ((forall a2 : form, (exists f : N, exists a : list term, exists b : list term, (a2 = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash4' (FEq l r)) a b)) -> vdash2_scong' a2) /\ (forall a3' : form, (exists s : term, exists t : term, (a3' = (FEq s t)) /\ ((s = t) \/ ((vdash2_sachain' (FEq s t)) \/ (vdash2_scchain' (FEq s t))))) -> vdash4' a3')))) -> vdash4' a3).
Proof. exact (eq_refl vdash4). Qed.
Definition vdash2_sachain : (form -> Prop) -> form -> Prop := fun E : form -> Prop => fun a0 : form => forall vdash2_sachain' : form -> Prop, forall vdash2_scchain' : form -> Prop, forall vdash2_scong' : form -> Prop, forall vdash4' : form -> Prop, ((forall a0' : form, ((exists s : term, exists t : term, (a0' = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0' = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ ((vdash4' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_sachain' a0') /\ ((forall a1 : form, ((exists s : term, exists t : term, (a1 = (FEq s t)) /\ (vdash2_scong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1 = (FEq s u)) /\ ((vdash2_scong' (FEq s t)) /\ ((vdash2_sachain' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_scchain' a1) /\ ((forall a2 : form, (exists f : N, exists a : list term, exists b : list term, (a2 = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash4' (FEq l r)) a b)) -> vdash2_scong' a2) /\ (forall a3 : form, (exists s : term, exists t : term, (a3 = (FEq s t)) /\ ((s = t) \/ ((vdash2_sachain' (FEq s t)) \/ (vdash2_scchain' (FEq s t))))) -> vdash4' a3)))) -> vdash2_sachain' a0.
Lemma vdash2_sachain_def : vdash2_sachain = (fun E : form -> Prop => fun a0 : form => forall vdash2_sachain' : form -> Prop, forall vdash2_scchain' : form -> Prop, forall vdash2_scong' : form -> Prop, forall vdash4' : form -> Prop, ((forall a0' : form, ((exists s : term, exists t : term, (a0' = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0' = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ ((vdash4' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_sachain' a0') /\ ((forall a1 : form, ((exists s : term, exists t : term, (a1 = (FEq s t)) /\ (vdash2_scong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1 = (FEq s u)) /\ ((vdash2_scong' (FEq s t)) /\ ((vdash2_sachain' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_scchain' a1) /\ ((forall a2 : form, (exists f : N, exists a : list term, exists b : list term, (a2 = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash4' (FEq l r)) a b)) -> vdash2_scong' a2) /\ (forall a3 : form, (exists s : term, exists t : term, (a3 = (FEq s t)) /\ ((s = t) \/ ((vdash2_sachain' (FEq s t)) \/ (vdash2_scchain' (FEq s t))))) -> vdash4' a3)))) -> vdash2_sachain' a0).
Proof. exact (eq_refl vdash2_sachain). Qed.
Definition vdash2_scchain : (form -> Prop) -> form -> Prop := fun E : form -> Prop => fun a1 : form => forall vdash2_sachain' : form -> Prop, forall vdash2_scchain' : form -> Prop, forall vdash2_scong' : form -> Prop, forall vdash4' : form -> Prop, ((forall a0 : form, ((exists s : term, exists t : term, (a0 = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0 = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ ((vdash4' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_sachain' a0) /\ ((forall a1' : form, ((exists s : term, exists t : term, (a1' = (FEq s t)) /\ (vdash2_scong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1' = (FEq s u)) /\ ((vdash2_scong' (FEq s t)) /\ ((vdash2_sachain' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_scchain' a1') /\ ((forall a2 : form, (exists f : N, exists a : list term, exists b : list term, (a2 = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash4' (FEq l r)) a b)) -> vdash2_scong' a2) /\ (forall a3 : form, (exists s : term, exists t : term, (a3 = (FEq s t)) /\ ((s = t) \/ ((vdash2_sachain' (FEq s t)) \/ (vdash2_scchain' (FEq s t))))) -> vdash4' a3)))) -> vdash2_scchain' a1.
Lemma vdash2_scchain_def : vdash2_scchain = (fun E : form -> Prop => fun a1 : form => forall vdash2_sachain' : form -> Prop, forall vdash2_scchain' : form -> Prop, forall vdash2_scong' : form -> Prop, forall vdash4' : form -> Prop, ((forall a0 : form, ((exists s : term, exists t : term, (a0 = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0 = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ ((vdash4' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_sachain' a0) /\ ((forall a1' : form, ((exists s : term, exists t : term, (a1' = (FEq s t)) /\ (vdash2_scong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1' = (FEq s u)) /\ ((vdash2_scong' (FEq s t)) /\ ((vdash2_sachain' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_scchain' a1') /\ ((forall a2 : form, (exists f : N, exists a : list term, exists b : list term, (a2 = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash4' (FEq l r)) a b)) -> vdash2_scong' a2) /\ (forall a3 : form, (exists s : term, exists t : term, (a3 = (FEq s t)) /\ ((s = t) \/ ((vdash2_sachain' (FEq s t)) \/ (vdash2_scchain' (FEq s t))))) -> vdash4' a3)))) -> vdash2_scchain' a1).
Proof. exact (eq_refl vdash2_scchain). Qed.
Definition vdash2_scong : (form -> Prop) -> form -> Prop := fun E : form -> Prop => fun a2 : form => forall vdash2_sachain' : form -> Prop, forall vdash2_scchain' : form -> Prop, forall vdash2_scong' : form -> Prop, forall vdash4' : form -> Prop, ((forall a0 : form, ((exists s : term, exists t : term, (a0 = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0 = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ ((vdash4' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_sachain' a0) /\ ((forall a1 : form, ((exists s : term, exists t : term, (a1 = (FEq s t)) /\ (vdash2_scong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1 = (FEq s u)) /\ ((vdash2_scong' (FEq s t)) /\ ((vdash2_sachain' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_scchain' a1) /\ ((forall a2' : form, (exists f : N, exists a : list term, exists b : list term, (a2' = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash4' (FEq l r)) a b)) -> vdash2_scong' a2') /\ (forall a3 : form, (exists s : term, exists t : term, (a3 = (FEq s t)) /\ ((s = t) \/ ((vdash2_sachain' (FEq s t)) \/ (vdash2_scchain' (FEq s t))))) -> vdash4' a3)))) -> vdash2_scong' a2.
Lemma vdash2_scong_def : vdash2_scong = (fun E : form -> Prop => fun a2 : form => forall vdash2_sachain' : form -> Prop, forall vdash2_scchain' : form -> Prop, forall vdash2_scong' : form -> Prop, forall vdash4' : form -> Prop, ((forall a0 : form, ((exists s : term, exists t : term, (a0 = (FEq s t)) /\ (vdash2_axiom E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0 = (FEq s u)) /\ ((vdash2_axiom E (FEq s t)) /\ ((vdash4' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_sachain' a0) /\ ((forall a1 : form, ((exists s : term, exists t : term, (a1 = (FEq s t)) /\ (vdash2_scong' (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1 = (FEq s u)) /\ ((vdash2_scong' (FEq s t)) /\ ((vdash2_sachain' (FEq t u)) /\ (@IN term t (esubterms E s u)))))) -> vdash2_scchain' a1) /\ ((forall a2' : form, (exists f : N, exists a : list term, exists b : list term, (a2' = (FEq (Fn f a) (Fn f b))) /\ (@List.Forall2 term term (fun l : term => fun r : term => vdash4' (FEq l r)) a b)) -> vdash2_scong' a2') /\ (forall a3 : form, (exists s : term, exists t : term, (a3 = (FEq s t)) /\ ((s = t) \/ ((vdash2_sachain' (FEq s t)) \/ (vdash2_scchain' (FEq s t))))) -> vdash4' a3)))) -> vdash2_scong' a2).
Proof. exact (eq_refl vdash2_scong). Qed.
Definition Eqclause_Func : (prod N N) -> form -> Prop := fun _554544 : prod N N => @set_of_list form (@cons form (FEq (Fn (@fst N N _554544) (@List.map (prod term term) term (@fst term term) (Varpairs (@snd N N _554544)))) (Fn (@fst N N _554544) (@List.map (prod term term) term (@snd term term) (Varpairs (@snd N N _554544))))) (@List.map (prod term term) form (@ε ((prod term term) -> form) (fun f : (prod term term) -> form => forall s : term, forall t : term, @eq form (f (@pair term term s t)) (Not (FEq s t)))) (Varpairs (@snd N N _554544)))).
Lemma Eqclause_Func_def : Eqclause_Func = (fun _554544 : prod N N => @set_of_list form (@cons form (FEq (Fn (@fst N N _554544) (@List.map (prod term term) term (@fst term term) (Varpairs (@snd N N _554544)))) (Fn (@fst N N _554544) (@List.map (prod term term) term (@snd term term) (Varpairs (@snd N N _554544))))) (@List.map (prod term term) form (@ε ((prod term term) -> form) (fun f : (prod term term) -> form => forall s : term, forall t : term, @eq form (f (@pair term term s t)) (Not (FEq s t)))) (Varpairs (@snd N N _554544))))).
Proof. exact (eq_refl Eqclause_Func). Qed.
Definition Eqclause_Pred : (prod N N) -> form -> Prop := fun _554553 : prod N N => @set_of_list form (@cons form (Atom (@fst N N _554553) (@List.map (prod term term) term (@snd term term) (Varpairs (@snd N N _554553)))) (@cons form (Not (Atom (@fst N N _554553) (@List.map (prod term term) term (@fst term term) (Varpairs (@snd N N _554553))))) (@List.map (prod term term) form (@ε ((prod term term) -> form) (fun f : (prod term term) -> form => forall s : term, forall t : term, @eq form (f (@pair term term s t)) (Not (FEq s t)))) (Varpairs (@snd N N _554553))))).
Lemma Eqclause_Pred_def : Eqclause_Pred = (fun _554553 : prod N N => @set_of_list form (@cons form (Atom (@fst N N _554553) (@List.map (prod term term) term (@snd term term) (Varpairs (@snd N N _554553)))) (@cons form (Not (Atom (@fst N N _554553) (@List.map (prod term term) term (@fst term term) (Varpairs (@snd N N _554553))))) (@List.map (prod term term) form (@ε ((prod term term) -> form) (fun f : (prod term term) -> form => forall s : term, forall t : term, @eq form (f (@pair term term s t)) (Not (FEq s t)))) (Varpairs (@snd N N _554553)))))).
Proof. exact (eq_refl Eqclause_Pred). Qed.
Definition Eqclauses : (prod ((prod N N) -> Prop) ((prod N N) -> Prop)) -> (form -> Prop) -> Prop := fun _554562 : prod ((prod N N) -> Prop) ((prod N N) -> Prop) => @INSERT (form -> Prop) (@INSERT form (FEq (V (NUMERAL N0)) (V (NUMERAL N0))) (@Ensembles.Empty_set form)) (@INSERT (form -> Prop) (@INSERT form (Not (FEq (V (NUMERAL N0)) (V (NUMERAL (BIT1 N0))))) (@INSERT form (Not (FEq (V (NUMERAL (BIT0 (BIT1 N0)))) (V (NUMERAL (BIT1 N0))))) (@INSERT form (FEq (V (NUMERAL N0)) (V (NUMERAL (BIT0 (BIT1 N0))))) (@Ensembles.Empty_set form)))) (@Ensembles.Union (form -> Prop) (@GSPEC (form -> Prop) (fun GEN_PVAR_666 : form -> Prop => exists fa : prod N N, @SETSPEC (form -> Prop) GEN_PVAR_666 (@IN (prod N N) fa (@fst ((prod N N) -> Prop) ((prod N N) -> Prop) _554562)) (Eqclause_Func fa))) (@GSPEC (form -> Prop) (fun GEN_PVAR_667 : form -> Prop => exists pa : prod N N, @SETSPEC (form -> Prop) GEN_PVAR_667 (@IN (prod N N) pa (@snd ((prod N N) -> Prop) ((prod N N) -> Prop) _554562)) (Eqclause_Pred pa))))).
Lemma Eqclauses_def : Eqclauses = (fun _554562 : prod ((prod N N) -> Prop) ((prod N N) -> Prop) => @INSERT (form -> Prop) (@INSERT form (FEq (V (NUMERAL N0)) (V (NUMERAL N0))) (@Ensembles.Empty_set form)) (@INSERT (form -> Prop) (@INSERT form (Not (FEq (V (NUMERAL N0)) (V (NUMERAL (BIT1 N0))))) (@INSERT form (Not (FEq (V (NUMERAL (BIT0 (BIT1 N0)))) (V (NUMERAL (BIT1 N0))))) (@INSERT form (FEq (V (NUMERAL N0)) (V (NUMERAL (BIT0 (BIT1 N0))))) (@Ensembles.Empty_set form)))) (@Ensembles.Union (form -> Prop) (@GSPEC (form -> Prop) (fun GEN_PVAR_666 : form -> Prop => exists fa : prod N N, @SETSPEC (form -> Prop) GEN_PVAR_666 (@IN (prod N N) fa (@fst ((prod N N) -> Prop) ((prod N N) -> Prop) _554562)) (Eqclause_Func fa))) (@GSPEC (form -> Prop) (fun GEN_PVAR_667 : form -> Prop => exists pa : prod N N, @SETSPEC (form -> Prop) GEN_PVAR_667 (@IN (prod N N) pa (@snd ((prod N N) -> Prop) ((prod N N) -> Prop) _554562)) (Eqclause_Pred pa)))))).
Proof. exact (eq_refl Eqclauses). Qed.
Definition Eqaxiom_Pred_imp : (prod N N) -> form := fun _554616 : prod N N => uclose (FImp (@fold_right_with_perm_args form form FAnd (@List.map (prod term term) form (@ε ((prod term term) -> form) (fun f : (prod term term) -> form => forall s : term, forall t : term, @eq form (f (@pair term term s t)) (FEq s t))) (Varpairs (@snd N N _554616))) FTrue) (FImp (Atom (@fst N N _554616) (@List.map (prod term term) term (@fst term term) (Varpairs (@snd N N _554616)))) (Atom (@fst N N _554616) (@List.map (prod term term) term (@snd term term) (Varpairs (@snd N N _554616)))))).
Lemma Eqaxiom_Pred_imp_def : Eqaxiom_Pred_imp = (fun _554616 : prod N N => uclose (FImp (@fold_right_with_perm_args form form FAnd (@List.map (prod term term) form (@ε ((prod term term) -> form) (fun f : (prod term term) -> form => forall s : term, forall t : term, @eq form (f (@pair term term s t)) (FEq s t))) (Varpairs (@snd N N _554616))) FTrue) (FImp (Atom (@fst N N _554616) (@List.map (prod term term) term (@fst term term) (Varpairs (@snd N N _554616)))) (Atom (@fst N N _554616) (@List.map (prod term term) term (@snd term term) (Varpairs (@snd N N _554616))))))).
Proof. exact (eq_refl Eqaxiom_Pred_imp). Qed.
Definition TRS : ((prod term term) -> Prop) -> term -> term -> Prop := fun rws : (prod term term) -> Prop => fun a0 : term => fun a1 : term => forall TRS' : term -> term -> Prop, (forall a0' : term, forall a1' : term, ((exists i : N -> term, exists l : term, exists r : term, (a0' = (termsubst i l)) /\ ((a1' = (termsubst i r)) /\ (@IN (prod term term) (@pair term term l r) rws))) \/ (exists s : term, exists t : term, exists f : N, exists largs : list term, exists rargs : list term, (a0' = (Fn f (@app term largs (@cons term s rargs)))) /\ ((a1' = (Fn f (@app term largs (@cons term t rargs)))) /\ (TRS' s t)))) -> TRS' a0' a1') -> TRS' a0 a1.
Lemma TRS_def : TRS = (fun rws : (prod term term) -> Prop => fun a0 : term => fun a1 : term => forall TRS' : term -> term -> Prop, (forall a0' : term, forall a1' : term, ((exists i : N -> term, exists l : term, exists r : term, (a0' = (termsubst i l)) /\ ((a1' = (termsubst i r)) /\ (@IN (prod term term) (@pair term term l r) rws))) \/ (exists s : term, exists t : term, exists f : N, exists largs : list term, exists rargs : list term, (a0' = (Fn f (@app term largs (@cons term s rargs)))) /\ ((a1' = (Fn f (@app term largs (@cons term t rargs)))) /\ (TRS' s t)))) -> TRS' a0' a1') -> TRS' a0 a1).
Proof. exact (eq_refl TRS). Qed.
Definition NONWF {A : Type'} : (A -> A -> Prop) -> A -> Prop := fun _563585 : A -> A -> Prop => fun _563586 : A => exists s : N -> A, ((s (NUMERAL N0)) = _563586) /\ (forall n : N, _563585 (s (N.succ n)) (s n)).
Lemma NONWF_def {A : Type'} : (@NONWF A) = (fun _563585 : A -> A -> Prop => fun _563586 : A => exists s : N -> A, ((s (NUMERAL N0)) = _563586) /\ (forall n : N, _563585 (s (N.succ n)) (s n))).
Proof. exact (eq_refl (@NONWF A)). Qed.
Definition termsize : term -> N := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> term -> N) (fun termsize' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> term -> N => forall _564457 : prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))), (forall x : N, (termsize' _564457 (V x)) = (NUMERAL (BIT1 N0))) /\ (forall f : N, forall args : list term, (termsize' _564457 (Fn f args)) = (@fold_right_with_perm_args N N N.add (@List.map term N (termsize' _564457) args) (NUMERAL (BIT1 N0))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0))))))))))))))).
Lemma termsize_def : termsize = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> term -> N) (fun termsize' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> term -> N => forall _564457 : prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))), (forall x : N, (termsize' _564457 (V x)) = (NUMERAL (BIT1 N0))) /\ (forall f : N, forall args : list term, (termsize' _564457 (Fn f args)) = (@fold_right_with_perm_args N N N.add (@List.map term N (termsize' _564457) args) (NUMERAL (BIT1 N0))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 N0)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 N0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 N0)))))))))))))))).
Proof. exact (eq_refl termsize). Qed.
Definition LEX {_250280 : Type'} : (_250280 -> _250280 -> Prop) -> (list _250280) -> (list _250280) -> Prop := @ε ((prod N (prod N N)) -> (_250280 -> _250280 -> Prop) -> (list _250280) -> (list _250280) -> Prop) (fun LEX' : (prod N (prod N N)) -> (_250280 -> _250280 -> Prop) -> (list _250280) -> (list _250280) -> Prop => forall _564465 : prod N (prod N N), (forall lt2' : _250280 -> _250280 -> Prop, forall l : list _250280, (LEX' _564465 lt2' (@nil _250280) l) = False) /\ (forall h : _250280, forall lt2' : _250280 -> _250280 -> Prop, forall t : list _250280, forall l : list _250280, (LEX' _564465 lt2' (@cons _250280 h t) l) = (@COND Prop (l = (@nil _250280)) False (@COND Prop (lt2' h (@HOLLight_Real_With_N.mappings.hd _250280 l)) ((@lengthN _250280 t) = (@lengthN _250280 (@HOLLight_Real_With_N.mappings.tl _250280 l))) ((h = (@HOLLight_Real_With_N.mappings.hd _250280 l)) /\ (LEX' _564465 lt2' t (@HOLLight_Real_With_N.mappings.tl _250280 l))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 N0)))))))))).
Lemma LEX_def {_250280 : Type'} : (@LEX _250280) = (@ε ((prod N (prod N N)) -> (_250280 -> _250280 -> Prop) -> (list _250280) -> (list _250280) -> Prop) (fun LEX' : (prod N (prod N N)) -> (_250280 -> _250280 -> Prop) -> (list _250280) -> (list _250280) -> Prop => forall _564465 : prod N (prod N N), (forall lt2' : _250280 -> _250280 -> Prop, forall l : list _250280, (LEX' _564465 lt2' (@nil _250280) l) = False) /\ (forall h : _250280, forall lt2' : _250280 -> _250280 -> Prop, forall t : list _250280, forall l : list _250280, (LEX' _564465 lt2' (@cons _250280 h t) l) = (@COND Prop (l = (@nil _250280)) False (@COND Prop (lt2' h (@HOLLight_Real_With_N.mappings.hd _250280 l)) ((@lengthN _250280 t) = (@lengthN _250280 (@HOLLight_Real_With_N.mappings.tl _250280 l))) ((h = (@HOLLight_Real_With_N.mappings.hd _250280 l)) /\ (LEX' _564465 lt2' t (@HOLLight_Real_With_N.mappings.tl _250280 l))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 N0)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 N0)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 N0))))))))))).
Proof. exact (eq_refl (@LEX _250280)). Qed.
Definition subterm : term -> term -> Prop := fun a0 : term => fun a1 : term => forall subterm' : term -> term -> Prop, (forall a0' : term, forall a1' : term, ((a1' = a0') \/ (exists a : term, exists f : N, exists args : list term, (a1' = (Fn f args)) /\ ((subterm' a0' a) /\ (@List.In term a args)))) -> subterm' a0' a1') -> subterm' a0 a1.
Lemma subterm_def : subterm = (fun a0 : term => fun a1 : term => forall subterm' : term -> term -> Prop, (forall a0' : term, forall a1' : term, ((a1' = a0') \/ (exists a : term, exists f : N, exists args : list term, (a1' = (Fn f args)) /\ ((subterm' a0' a) /\ (@List.In term a args)))) -> subterm' a0' a1') -> subterm' a0 a1).
Proof. exact (eq_refl subterm). Qed.
Definition psubterm : term -> term -> Prop := fun _567009 : term => fun _567010 : term => (subterm _567009 _567010) /\ (~ (_567009 = _567010)).
Lemma psubterm_def : psubterm = (fun _567009 : term => fun _567010 : term => (subterm _567009 _567010) /\ (~ (_567009 = _567010))).
Proof. exact (eq_refl psubterm). Qed.
Definition lt2 : term -> term -> Prop := fun a0 : term => fun a1 : term => forall lt2' : term -> term -> Prop, (forall a0' : term, forall a1' : term, ((exists x : N, (a0' = (V x)) /\ ((@IN N x (free_variables_term a1')) /\ (~ (a1' = (V x))))) \/ ((exists fs : N, exists sargs : list term, exists ft : N, exists targs : list term, exists si : term, (a0' = (Fn ft targs)) /\ ((a1' = (Fn fs sargs)) /\ ((@List.In term si sargs) /\ ((lt2' (Fn ft targs) si) \/ (si = (Fn ft targs)))))) \/ ((exists fs : N, exists ft : N, exists sargs : list term, exists targs : list term, (a0' = (Fn ft targs)) /\ ((a1' = (Fn fs sargs)) /\ (((N.gt fs ft) \/ ((fs = ft) /\ (N.gt (@lengthN term sargs) (@lengthN term targs)))) /\ (@List.Forall term (fun ti : term => lt2' ti (Fn fs sargs)) targs)))) \/ (exists f : N, exists sargs : list term, exists targs : list term, (a0' = (Fn f targs)) /\ ((a1' = (Fn f sargs)) /\ ((@List.Forall term (fun ti : term => lt2' ti (Fn f sargs)) targs) /\ (@LEX term lt2' targs sargs))))))) -> lt2' a0' a1') -> lt2' a0 a1.
Lemma lt2_def : lt2 = (fun a0 : term => fun a1 : term => forall lt2' : term -> term -> Prop, (forall a0' : term, forall a1' : term, ((exists x : N, (a0' = (V x)) /\ ((@IN N x (free_variables_term a1')) /\ (~ (a1' = (V x))))) \/ ((exists fs : N, exists sargs : list term, exists ft : N, exists targs : list term, exists si : term, (a0' = (Fn ft targs)) /\ ((a1' = (Fn fs sargs)) /\ ((@List.In term si sargs) /\ ((lt2' (Fn ft targs) si) \/ (si = (Fn ft targs)))))) \/ ((exists fs : N, exists ft : N, exists sargs : list term, exists targs : list term, (a0' = (Fn ft targs)) /\ ((a1' = (Fn fs sargs)) /\ (((N.gt fs ft) \/ ((fs = ft) /\ (N.gt (@lengthN term sargs) (@lengthN term targs)))) /\ (@List.Forall term (fun ti : term => lt2' ti (Fn fs sargs)) targs)))) \/ (exists f : N, exists sargs : list term, exists targs : list term, (a0' = (Fn f targs)) /\ ((a1' = (Fn f sargs)) /\ ((@List.Forall term (fun ti : term => lt2' ti (Fn f sargs)) targs) /\ (@LEX term lt2' targs sargs))))))) -> lt2' a0' a1') -> lt2' a0 a1).
Proof. exact (eq_refl lt2). Qed.
